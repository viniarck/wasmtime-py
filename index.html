<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>wasmtime API documentation</title>
<meta name="description" content="Python bindings for the [Wasmtime project] …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>wasmtime</code></h1>
</header>
<section id="section-intro">
<p>Python bindings for the <a href="https://github.com/bytecodealliance/wasmtime">Wasmtime project</a></p>
<p>This library binds the <a href="https://github.com/bytecodealliance/wasmtime">Wasmtime project</a>'s C API to provide an implementation
of a WebAssembly JIT compiler to Python. You can validate, compile, instantiate,
and interact with WebAssembly modules via this library.</p>
<p>The API of this library is intended to be very similar to the <a href="https://docs.rs/wasmtime"><code>wasmtime</code> Rust
crate</a>, so if you find the docs are lacking here feel
free to consult that documentation as well. While not exactly the same the two
libraries are intended to be quite similar.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Python bindings for the [Wasmtime project]

[Wasmtime project]: https://github.com/bytecodealliance/wasmtime

This library binds the [Wasmtime project]&#39;s C API to provide an implementation
of a WebAssembly JIT compiler to Python. You can validate, compile, instantiate,
and interact with WebAssembly modules via this library.

The API of this library is intended to be very similar to the [`wasmtime` Rust
crate](https://docs.rs/wasmtime), so if you find the docs are lacking here feel
free to consult that documentation as well. While not exactly the same the two
libraries are intended to be quite similar.
&#34;&#34;&#34;

from ._error import WasmtimeError
from ._config import Config
from ._engine import Engine
from ._store import Store
from ._types import FuncType, GlobalType, MemoryType, TableType
from ._types import ValType, Limits, ImportType, ExportType
from ._wat2wasm import wat2wasm
from ._module import Module
from ._value import Val, IntoVal
from ._trap import Trap, Frame, ExitTrap
from ._func import Func, Caller
from ._globals import Global
from ._table import Table
from ._memory import Memory
from ._instance import Instance
from ._wasi import WasiInstance, WasiConfig
from ._linker import Linker

__all__ = [
    &#39;wat2wasm&#39;,
    &#39;Config&#39;,
    &#39;Engine&#39;,
    &#39;Store&#39;,
    &#39;FuncType&#39;,
    &#39;GlobalType&#39;,
    &#39;MemoryType&#39;,
    &#39;TableType&#39;,
    &#39;ValType&#39;,
    &#39;Limits&#39;,
    &#39;ImportType&#39;,
    &#39;ExportType&#39;,
    &#39;IntoVal&#39;,
    &#39;Val&#39;,
    &#39;Func&#39;,
    &#39;Caller&#39;,
    &#39;Table&#39;,
    &#39;Memory&#39;,
    &#39;Global&#39;,
    &#39;Trap&#39;,
    &#39;ExitTrap&#39;,
    &#39;Frame&#39;,
    &#39;Module&#39;,
    &#39;Instance&#39;,
    &#39;WasiConfig&#39;,
    &#39;WasiInstance&#39;,
    &#39;Linker&#39;,
    &#39;WasmtimeError&#39;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="wasmtime.loader" href="loader.html">wasmtime.loader</a></code></dt>
<dd>
<div class="desc"><p>This module is a custom loader for Python which enables importing wasm files
directly into Python programs simply through usage of the <code>import</code> …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="wasmtime.wat2wasm"><code class="name flex">
<span>def <span class="ident">wat2wasm</span></span>(<span>wat: Union[str, bytes]) ‑> bytearray</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the <a href="https://webassembly.github.io/spec/core/text/index.html">WebAssembly Text format</a> to the binary format.</p>
<p>This function is intended to be a convenience function for local
development and you likely don't want to use it extensively in production.
It's much faster to parse and compile the binary format than it is to
process the text format.</p>
<p>Takes a <code>str</code> as input, raises an error if it fails to parse, and returns
a <code>bytes</code> if conversion/parsing was successful.</p>
<pre><code class="python">&gt;&gt;&gt; wat2wasm('(module)')
bytearray(b'\x00asm\x01\x00\x00\x00')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wat2wasm(wat: typing.Union[str, bytes]) -&gt; bytearray:
    &#34;&#34;&#34;
    Converts the [WebAssembly Text format][wat] to the binary format.

    This function is intended to be a convenience function for local
    development and you likely don&#39;t want to use it extensively in production.
    It&#39;s much faster to parse and compile the binary format than it is to
    process the text format.

    Takes a `str` as input, raises an error if it fails to parse, and returns
    a `bytes` if conversion/parsing was successful.

    &gt;&gt;&gt; wat2wasm(&#39;(module)&#39;)
    bytearray(b&#39;\\x00asm\\x01\\x00\\x00\\x00&#39;)

    [wat]: https://webassembly.github.io/spec/core/text/index.html
    &#34;&#34;&#34;

    if isinstance(wat, str):
        wat = wat.encode(&#39;utf8&#39;)
    wat_buffer = cast(create_string_buffer(wat), POINTER(c_uint8))
    wat_bytes = ffi.wasm_byte_vec_t(len(wat), wat_buffer)
    wasm = ffi.wasm_byte_vec_t()
    error = ffi.wasmtime_wat2wasm(byref(wat_bytes), byref(wasm))
    if error:
        raise WasmtimeError._from_ptr(error)
    else:
        ret = ffi.to_bytes(wasm)
        ffi.wasm_byte_vec_delete(byref(wasm))
        return ret</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="wasmtime.Caller"><code class="flex name class">
<span>class <span class="ident">Caller</span></span>
<span>(</span><span>ptr: <built-in function pointer>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Caller:
    def __init__(self, ptr: pointer):
        self._ptr = ptr

    def __getitem__(self, name: str) -&gt; AsExtern:
        &#34;&#34;&#34;
        Looks up an export with `name` on the calling module.

        If `name` isn&#39;t defined on the calling module, or if the caller has gone
        away for some reason, then this will raise a `KeyError`. For more
        information about when this could fail see the `get` method which
        returns `None` on failure.
        &#34;&#34;&#34;

        ret = self.get(name)
        if ret is None:
            raise KeyError(&#34;failed to find export {}&#34;.format(name))
        return ret

    def get(self, name: str) -&gt; Optional[AsExtern]:
        &#34;&#34;&#34;
        Looks up an export with `name` on the calling module.

        May return `None` if the export isn&#39;t found, if it&#39;s not a memory (for
        now), or if the caller has gone away and this `Caller` object has
        persisted too long.
        &#34;&#34;&#34;

        # First convert to a raw name so we can typecheck our argument
        name_raw = ffi.str_to_name(name)

        # Next see if we&#39;ve been invalidated
        if not hasattr(self, &#39;_ptr&#39;):
            return None

        # And if we&#39;re not invalidated we can perform the actual lookup
        ptr = ffi.wasmtime_caller_export_get(self._ptr, byref(name_raw))
        if ptr:
            return wrap_extern(ptr, None)
        else:
            return None</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="wasmtime.Caller.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, name: str) ‑> Union[ForwardRef('<a title="wasmtime.Func" href="#wasmtime.Func">Func</a>'), ForwardRef('<a title="wasmtime.Table" href="#wasmtime.Table">Table</a>'), ForwardRef('<a title="wasmtime.Memory" href="#wasmtime.Memory">Memory</a>'), ForwardRef('<a title="wasmtime.Global" href="#wasmtime.Global">Global</a>'), NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Looks up an export with <code>name</code> on the calling module.</p>
<p>May return <code>None</code> if the export isn't found, if it's not a memory (for
now), or if the caller has gone away and this <code><a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a></code> object has
persisted too long.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, name: str) -&gt; Optional[AsExtern]:
    &#34;&#34;&#34;
    Looks up an export with `name` on the calling module.

    May return `None` if the export isn&#39;t found, if it&#39;s not a memory (for
    now), or if the caller has gone away and this `Caller` object has
    persisted too long.
    &#34;&#34;&#34;

    # First convert to a raw name so we can typecheck our argument
    name_raw = ffi.str_to_name(name)

    # Next see if we&#39;ve been invalidated
    if not hasattr(self, &#39;_ptr&#39;):
        return None

    # And if we&#39;re not invalidated we can perform the actual lookup
    ptr = ffi.wasmtime_caller_export_get(self._ptr, byref(name_raw))
    if ptr:
        return wrap_extern(ptr, None)
    else:
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.Config"><code class="flex name class">
<span>class <span class="ident">Config</span></span>
</code></dt>
<dd>
<div class="desc"><p>Global configuration, used to create an <code><a title="wasmtime.Engine" href="#wasmtime.Engine">Engine</a></code>.</p>
<p>A <code><a title="wasmtime.Config" href="#wasmtime.Config">Config</a></code> houses a number of configuration options which tweaks how wasm
code is compiled or generated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Config:
    &#34;&#34;&#34;
    Global configuration, used to create an `Engine`.

    A `Config` houses a number of configuration options which tweaks how wasm
    code is compiled or generated.
    &#34;&#34;&#34;

    def __init__(self) -&gt; None:
        self._ptr = ffi.wasm_config_new()

    @setter_property
    def debug_info(self, enable: bool) -&gt; None:
        &#34;&#34;&#34;
        Configures whether DWARF debug information is emitted for the generated
        code. This can improve profiling and the debugging experience.
        &#34;&#34;&#34;

        if not isinstance(enable, bool):
            raise TypeError(&#39;expected a bool&#39;)
        ffi.wasmtime_config_debug_info_set(self._ptr, enable)

    @setter_property
    def wasm_threads(self, enable: bool) -&gt; None:
        &#34;&#34;&#34;
        Configures whether the wasm [threads proposal] is enabled.

        [threads proposal]: https://github.com/webassembly/threads
        &#34;&#34;&#34;

        if not isinstance(enable, bool):
            raise TypeError(&#39;expected a bool&#39;)
        ffi.wasmtime_config_wasm_threads_set(self._ptr, enable)

    @setter_property
    def wasm_reference_types(self, enable: bool) -&gt; None:
        &#34;&#34;&#34;
        Configures whether the wasm [reference types proposal] is enabled.

        [reference types proposal]: https://github.com/webassembly/reference-types
        &#34;&#34;&#34;

        if not isinstance(enable, bool):
            raise TypeError(&#39;expected a bool&#39;)
        ffi.wasmtime_config_wasm_reference_types_set(self._ptr, enable)

    @setter_property
    def wasm_simd(self, enable: bool) -&gt; None:
        &#34;&#34;&#34;
        Configures whether the wasm [SIMD proposal] is enabled.

        [SIMD proposal]: https://github.com/webassembly/simd
        &#34;&#34;&#34;

        if not isinstance(enable, bool):
            raise TypeError(&#39;expected a bool&#39;)
        ffi.wasmtime_config_wasm_simd_set(self._ptr, enable)

    @setter_property
    def wasm_bulk_memory(self, enable: bool) -&gt; None:
        &#34;&#34;&#34;
        Configures whether the wasm [bulk memory proposal] is enabled.

        [bulk memory proposal]: https://github.com/webassembly/bulk-memory
        &#34;&#34;&#34;

        if not isinstance(enable, bool):
            raise TypeError(&#39;expected a bool&#39;)
        ffi.wasmtime_config_wasm_bulk_memory_set(self._ptr, enable)

    @setter_property
    def wasm_multi_value(self, enable: bool) -&gt; None:
        &#34;&#34;&#34;
        Configures whether the wasm [multi value proposal] is enabled.

        [multi value proposal]: https://github.com/webassembly/multi-value
        &#34;&#34;&#34;

        if not isinstance(enable, bool):
            raise TypeError(&#39;expected a bool&#39;)
        ffi.wasmtime_config_wasm_multi_value_set(self._ptr, enable)

    @setter_property
    def strategy(self, strategy: str) -&gt; None:
        &#34;&#34;&#34;
        Configures the compilation strategy used for wasm code.

        Acceptable values for `strategy` are:

        * `&#34;auto&#34;`
        * `&#34;cranelift&#34;`
        * `&#34;lightbeam&#34;`
        &#34;&#34;&#34;

        if strategy == &#34;auto&#34;:
            error = ffi.wasmtime_config_strategy_set(self._ptr, 0)
        elif strategy == &#34;cranelift&#34;:
            error = ffi.wasmtime_config_strategy_set(self._ptr, 1)
        elif strategy == &#34;lightbeam&#34;:
            error = ffi.wasmtime_config_strategy_set(self._ptr, 2)
        else:
            raise WasmtimeError(&#34;unknown strategy: &#34; + str(strategy))
        if error:
            raise WasmtimeError._from_ptr(error)

    @setter_property
    def cranelift_debug_verifier(self, enable: bool) -&gt; None:
        if not isinstance(enable, bool):
            raise TypeError(&#39;expected a bool&#39;)
        ffi.wasmtime_config_cranelift_debug_verifier_set(self._ptr, enable)

    @setter_property
    def cranelift_opt_level(self, opt_level: str) -&gt; None:
        if opt_level == &#34;none&#34;:
            ffi.wasmtime_config_cranelift_opt_level_set(self._ptr, 0)
        elif opt_level == &#34;speed&#34;:
            ffi.wasmtime_config_cranelift_opt_level_set(self._ptr, 1)
        elif opt_level == &#34;speed_and_size&#34;:
            ffi.wasmtime_config_cranelift_opt_level_set(self._ptr, 2)
        else:
            raise WasmtimeError(&#34;unknown opt level: &#34; + str(opt_level))

    @setter_property
    def profiler(self, profiler: str) -&gt; None:
        if profiler == &#34;none&#34;:
            error = ffi.wasmtime_config_profiler_set(self._ptr, 0)
        elif profiler == &#34;jitdump&#34;:
            error = ffi.wasmtime_config_profiler_set(self._ptr, 1)
        else:
            raise WasmtimeError(&#34;unknown profiler: &#34; + str(profiler))
        if error:
            raise WasmtimeError._from_ptr(error)

    @setter_property
    def cache(self, enabled: typing.Union[bool, str]) -&gt; None:
        &#34;&#34;&#34;
        Configures whether code caching is enabled for this `Config`.

        The value `True` can be passed in here to enable the default caching
        configuration and location, or a path to a file can be passed in which
        is a path to a TOML configuration file for the cache.

        More information about cache configuration can be found at
        https://bytecodealliance.github.io/wasmtime/cli-cache.html
        &#34;&#34;&#34;

        if isinstance(enabled, bool):
            if not enabled:
                raise WasmtimeError(&#34;caching cannot be explicitly disabled&#34;)
            error = ffi.wasmtime_config_cache_config_load(self._ptr, None)
        elif isinstance(enabled, str):
            error = ffi.wasmtime_config_cache_config_load(self._ptr,
                                                          c_char_p(enabled.encode(&#39;utf-8&#39;)))
        else:
            raise TypeError(&#34;expected string or bool&#34;)
        if error:
            raise WasmtimeError._from_ptr(error)

    @setter_property
    def interruptable(self, enabled: bool) -&gt; None:
        &#34;&#34;&#34;
        Configures whether wasm execution can be interrupted via interrupt
        handles.
        &#34;&#34;&#34;

        if enabled:
            val = 1
        else:
            val = 0
        ffi.wasmtime_config_interruptable_set(self._ptr, val)

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_ptr&#39;):
            ffi.wasm_config_delete(self._ptr)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.Config.cache"><code class="name">var <span class="ident">cache</span></code></dt>
<dd>
<div class="desc"><p>Configures whether code caching is enabled for this <code><a title="wasmtime.Config" href="#wasmtime.Config">Config</a></code>.</p>
<p>The value <code>True</code> can be passed in here to enable the default caching
configuration and location, or a path to a file can be passed in which
is a path to a TOML configuration file for the cache.</p>
<p>More information about cache configuration can be found at
<a href="https://bytecodealliance.github.io/wasmtime/cli-cache.html">https://bytecodealliance.github.io/wasmtime/cli-cache.html</a></p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.Config.cranelift_debug_verifier"><code class="name">var <span class="ident">cranelift_debug_verifier</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wasmtime.Config.cranelift_opt_level"><code class="name">var <span class="ident">cranelift_opt_level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wasmtime.Config.debug_info"><code class="name">var <span class="ident">debug_info</span></code></dt>
<dd>
<div class="desc"><p>Configures whether DWARF debug information is emitted for the generated
code. This can improve profiling and the debugging experience.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.Config.interruptable"><code class="name">var <span class="ident">interruptable</span></code></dt>
<dd>
<div class="desc"><p>Configures whether wasm execution can be interrupted via interrupt
handles.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.Config.profiler"><code class="name">var <span class="ident">profiler</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="wasmtime.Config.strategy"><code class="name">var <span class="ident">strategy</span></code></dt>
<dd>
<div class="desc"><p>Configures the compilation strategy used for wasm code.</p>
<p>Acceptable values for <code>strategy</code> are:</p>
<ul>
<li><code>"auto"</code></li>
<li><code>"cranelift"</code></li>
<li><code>"lightbeam"</code></li>
</ul>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.Config.wasm_bulk_memory"><code class="name">var <span class="ident">wasm_bulk_memory</span></code></dt>
<dd>
<div class="desc"><p>Configures whether the wasm <a href="https://github.com/webassembly/bulk-memory">bulk memory proposal</a> is enabled.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.Config.wasm_multi_value"><code class="name">var <span class="ident">wasm_multi_value</span></code></dt>
<dd>
<div class="desc"><p>Configures whether the wasm <a href="https://github.com/webassembly/multi-value">multi value proposal</a> is enabled.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.Config.wasm_reference_types"><code class="name">var <span class="ident">wasm_reference_types</span></code></dt>
<dd>
<div class="desc"><p>Configures whether the wasm <a href="https://github.com/webassembly/reference-types">reference types proposal</a> is enabled.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.Config.wasm_simd"><code class="name">var <span class="ident">wasm_simd</span></code></dt>
<dd>
<div class="desc"><p>Configures whether the wasm <a href="https://github.com/webassembly/simd">SIMD proposal</a> is enabled.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.Config.wasm_threads"><code class="name">var <span class="ident">wasm_threads</span></code></dt>
<dd>
<div class="desc"><p>Configures whether the wasm <a href="https://github.com/webassembly/threads">threads proposal</a> is enabled.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
</dl>
</dd>
<dt id="wasmtime.Engine"><code class="flex name class">
<span>class <span class="ident">Engine</span></span>
<span>(</span><span>config: wasmtime._config.Config = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Engine:
    def __init__(self, config: Config = None):
        if config is None:
            self._ptr = ffi.wasm_engine_new()
        elif not isinstance(config, Config):
            raise TypeError(&#34;expected Config&#34;)
        elif not hasattr(config, &#39;_ptr&#39;):
            raise WasmtimeError(&#34;Config already used&#34;)
        else:
            ptr = config._ptr
            delattr(config, &#39;_ptr&#39;)
            self._ptr = ffi.wasm_engine_new_with_config(ptr)

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_ptr&#39;):
            ffi.wasm_engine_delete(self._ptr)</code></pre>
</details>
</dd>
<dt id="wasmtime.ExitTrap"><code class="flex name class">
<span>class <span class="ident">ExitTrap</span></span>
<span>(</span><span>store: wasmtime._store.Store, message: str)</span>
</code></dt>
<dd>
<div class="desc"><p>A special type of <code><a title="wasmtime.Trap" href="#wasmtime.Trap">Trap</a></code> which represents the process exiting via WASI's
<code>proc_exit</code> function call.</p>
<p>Whenever a WASI program exits via <code>proc_exit</code> a trap is raised, but the
trap will have this type instead of <code><a title="wasmtime.Trap" href="#wasmtime.Trap">Trap</a></code>, so you can catch just this
type instead of all traps (if desired). Exit traps have a <code>code</code> associated
with them which is the exit code provided at exit.</p>
<p>Note that <code><a title="wasmtime.ExitTrap" href="#wasmtime.ExitTrap">ExitTrap</a></code> is a subclass of <code><a title="wasmtime.Trap" href="#wasmtime.Trap">Trap</a></code>, so if you catch a trap you'll
also catch <code><a title="wasmtime.ExitTrap" href="#wasmtime.ExitTrap">ExitTrap</a></code>.</p>
<p>Creates a new trap in <code>store</code> with the given <code>message</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExitTrap(Trap):
    &#34;&#34;&#34;
    A special type of `Trap` which represents the process exiting via WASI&#39;s
    `proc_exit` function call.

    Whenever a WASI program exits via `proc_exit` a trap is raised, but the
    trap will have this type instead of `Trap`, so you can catch just this
    type instead of all traps (if desired). Exit traps have a `code` associated
    with them which is the exit code provided at exit.

    Note that `ExitTrap` is a subclass of `Trap`, so if you catch a trap you&#39;ll
    also catch `ExitTrap`.
    &#34;&#34;&#34;
    code: int
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>wasmtime._trap.Trap</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="wasmtime.ExportType"><code class="flex name class">
<span>class <span class="ident">ExportType</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExportType:
    _ptr: &#34;pointer[ffi.wasm_exporttype_t]&#34;
    _owner: Optional[Any]

    @classmethod
    def _from_ptr(cls, ptr: &#39;pointer[ffi.wasm_exporttype_t]&#39;, owner: Optional[Any]) -&gt; &#34;ExportType&#34;:
        ty: &#34;ExportType&#34; = cls.__new__(cls)
        if not isinstance(ptr, POINTER(ffi.wasm_exporttype_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        ty._ptr = ptr
        ty._owner = owner
        return ty

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the name in the modulethis export type refers to
        &#34;&#34;&#34;
        return ffi.to_str(ffi.wasm_exporttype_name(self._ptr).contents)

    @property
    def type(self) -&gt; &#34;AsExternType&#34;:
        &#34;&#34;&#34;
        Returns the type that this export refers to
        &#34;&#34;&#34;
        ptr = ffi.wasm_exporttype_type(self._ptr)
        return wrap_externtype(ptr, self._owner or self)

    def __del__(self) -&gt; None:
        if self._owner is None:
            ffi.wasm_exporttype_delete(self._ptr)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.ExportType.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>Returns the name in the modulethis export type refers to</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;
    Returns the name in the modulethis export type refers to
    &#34;&#34;&#34;
    return ffi.to_str(ffi.wasm_exporttype_name(self._ptr).contents)</code></pre>
</details>
</dd>
<dt id="wasmtime.ExportType.type"><code class="name">var <span class="ident">type</span> : Union[wasmtime._types.FuncType, wasmtime._types.TableType, wasmtime._types.MemoryType, wasmtime._types.GlobalType]</code></dt>
<dd>
<div class="desc"><p>Returns the type that this export refers to</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; &#34;AsExternType&#34;:
    &#34;&#34;&#34;
    Returns the type that this export refers to
    &#34;&#34;&#34;
    ptr = ffi.wasm_exporttype_type(self._ptr)
    return wrap_externtype(ptr, self._owner or self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.Frame"><code class="flex name class">
<span>class <span class="ident">Frame</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Frame:
    _ptr: &#34;pointer[ffi.wasm_frame_t]&#34;
    _owner: Optional[Any]

    @classmethod
    def _from_ptr(cls, ptr: &#34;pointer[ffi.wasm_frame_t]&#34;, owner: Optional[Any]) -&gt; &#34;Frame&#34;:
        ty: &#34;Frame&#34; = cls.__new__(cls)
        if not isinstance(ptr, POINTER(ffi.wasm_frame_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        ty._ptr = ptr
        ty._owner = owner
        return ty

    @property
    def func_index(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the function index this frame corresponds to in its wasm module
        &#34;&#34;&#34;

        return ffi.wasm_frame_func_index(self._ptr)

    @property
    def func_name(self) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Returns the name of the function this frame corresponds to

        May return `None` if no name can be inferred
        &#34;&#34;&#34;

        ptr = ffi.wasmtime_frame_func_name(self._ptr)
        if ptr:
            return ffi.to_str(ptr.contents)
        else:
            return None

    @property
    def module_name(self) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Returns the name of the module this frame corresponds to

        May return `None` if no name can be inferred
        &#34;&#34;&#34;

        ptr = ffi.wasmtime_frame_module_name(self._ptr)
        if ptr:
            return ffi.to_str(ptr.contents)
        else:
            return None

    @property
    def module_offset(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the offset of this frame&#39;s program counter into the original
        wasm source module.
        &#34;&#34;&#34;

        return ffi.wasm_frame_module_offset(self._ptr)

    @property
    def func_offset(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the offset of this frame&#39;s program counter into the original
        wasm function.
        &#34;&#34;&#34;

        return ffi.wasm_frame_func_offset(self._ptr)

    def __del__(self) -&gt; None:
        if self._owner is None:
            ffi.wasm_frame_delete(self._ptr)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.Frame.func_index"><code class="name">var <span class="ident">func_index</span> : int</code></dt>
<dd>
<div class="desc"><p>Returns the function index this frame corresponds to in its wasm module</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def func_index(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the function index this frame corresponds to in its wasm module
    &#34;&#34;&#34;

    return ffi.wasm_frame_func_index(self._ptr)</code></pre>
</details>
</dd>
<dt id="wasmtime.Frame.func_name"><code class="name">var <span class="ident">func_name</span> : Union[str, NoneType]</code></dt>
<dd>
<div class="desc"><p>Returns the name of the function this frame corresponds to</p>
<p>May return <code>None</code> if no name can be inferred</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def func_name(self) -&gt; Optional[str]:
    &#34;&#34;&#34;
    Returns the name of the function this frame corresponds to

    May return `None` if no name can be inferred
    &#34;&#34;&#34;

    ptr = ffi.wasmtime_frame_func_name(self._ptr)
    if ptr:
        return ffi.to_str(ptr.contents)
    else:
        return None</code></pre>
</details>
</dd>
<dt id="wasmtime.Frame.func_offset"><code class="name">var <span class="ident">func_offset</span> : int</code></dt>
<dd>
<div class="desc"><p>Returns the offset of this frame's program counter into the original
wasm function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def func_offset(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the offset of this frame&#39;s program counter into the original
    wasm function.
    &#34;&#34;&#34;

    return ffi.wasm_frame_func_offset(self._ptr)</code></pre>
</details>
</dd>
<dt id="wasmtime.Frame.module_name"><code class="name">var <span class="ident">module_name</span> : Union[str, NoneType]</code></dt>
<dd>
<div class="desc"><p>Returns the name of the module this frame corresponds to</p>
<p>May return <code>None</code> if no name can be inferred</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def module_name(self) -&gt; Optional[str]:
    &#34;&#34;&#34;
    Returns the name of the module this frame corresponds to

    May return `None` if no name can be inferred
    &#34;&#34;&#34;

    ptr = ffi.wasmtime_frame_module_name(self._ptr)
    if ptr:
        return ffi.to_str(ptr.contents)
    else:
        return None</code></pre>
</details>
</dd>
<dt id="wasmtime.Frame.module_offset"><code class="name">var <span class="ident">module_offset</span> : int</code></dt>
<dd>
<div class="desc"><p>Returns the offset of this frame's program counter into the original
wasm source module.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def module_offset(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the offset of this frame&#39;s program counter into the original
    wasm source module.
    &#34;&#34;&#34;

    return ffi.wasm_frame_module_offset(self._ptr)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.Func"><code class="flex name class">
<span>class <span class="ident">Func</span></span>
<span>(</span><span>store: wasmtime._store.Store, ty: wasmtime._types.FuncType, func: Callable, access_caller: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new func in <code>store</code> with the given <code>ty</code> which calls the closure
given</p>
<p>The <code>func</code> is called with the parameters natively and they'll have native
Python values rather than being wrapped in <code><a title="wasmtime.Val" href="#wasmtime.Val">Val</a></code>. If <code>access_caller</code> is
set to <code>True</code> then the first argument given to <code>func</code> is an instance of
type <code><a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a></code> below.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Func:
    _ptr: &#34;pointer[ffi.wasm_func_t]&#34;

    def __init__(self, store: Store, ty: FuncType, func: Callable, access_caller: bool = False):
        &#34;&#34;&#34;
        Creates a new func in `store` with the given `ty` which calls the closure
        given

        The `func` is called with the parameters natively and they&#39;ll have native
        Python values rather than being wrapped in `Val`. If `access_caller` is
        set to `True` then the first argument given to `func` is an instance of
        type `Caller` below.
        &#34;&#34;&#34;

        if not isinstance(store, Store):
            raise TypeError(&#34;expected a Store&#34;)
        if not isinstance(ty, FuncType):
            raise TypeError(&#34;expected a FuncType&#34;)
        idx = FUNCTIONS.allocate((func, ty.params, ty.results, store))
        if access_caller:
            ptr = ffi.wasmtime_func_new_with_env(
                store._ptr,
                ty._ptr,
                trampoline_with_caller,
                idx,
                finalize)
        else:
            ptr = ffi.wasm_func_new_with_env(
                store._ptr, ty._ptr, trampoline, idx, finalize)
        if not ptr:
            FUNCTIONS.deallocate(idx)
            raise WasmtimeError(&#34;failed to create func&#34;)
        self._ptr = ptr
        self._owner = None

    @classmethod
    def _from_ptr(cls, ptr: &#34;pointer[ffi.wasm_func_t]&#34;, owner: Optional[Any]) -&gt; &#34;Func&#34;:
        ty: &#34;Func&#34; = cls.__new__(cls)
        if not isinstance(ptr, POINTER(ffi.wasm_func_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        ty._ptr = ptr
        ty._owner = owner
        return ty

    @property
    def type(self) -&gt; FuncType:
        &#34;&#34;&#34;
        Gets the type of this func as a `FuncType`
        &#34;&#34;&#34;
        ptr = ffi.wasm_func_type(self._ptr)
        return FuncType._from_ptr(ptr, None)

    @property
    def param_arity(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of parameters this function expects
        &#34;&#34;&#34;
        return ffi.wasm_func_param_arity(self._ptr)

    @property
    def result_arity(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of results this function produces
        &#34;&#34;&#34;
        return ffi.wasm_func_result_arity(self._ptr)

    def __call__(self, *params: IntoVal) -&gt; Union[IntoVal, Sequence[IntoVal], None]:
        &#34;&#34;&#34;
        Calls this function with the given parameters

        Parameters can either be a `Val` or a native python value which can be
        converted to a `Val` of the corresponding correct type

        Returns `None` if this func has 0 return types
        Returns a single value if the func has 1 return type
        Returns a list if the func has more than 1 return type

        Note that you can also use the `__call__` method and invoke a `Func` as
        if it were a function directly.
        &#34;&#34;&#34;

        ty = self.type
        param_tys = ty.params
        if len(params) &gt; len(param_tys):
            raise WasmtimeError(&#34;too many parameters provided: given %s, expected %s&#34; %
                                (len(params), len(param_tys)))
        if len(params) &lt; len(param_tys):
            raise WasmtimeError(&#34;too few parameters provided: given %s, expected %s&#34; %
                                (len(params), len(param_tys)))

        param_vals = [Val._convert(ty, params[i]) for i, ty in enumerate(param_tys)]
        params_ptr = (ffi.wasm_val_t * len(params))()
        for i, val in enumerate(param_vals):
            params_ptr[i] = val._unwrap_raw()

        result_tys = ty.results
        results_ptr = (ffi.wasm_val_t * len(result_tys))()

        trap = POINTER(ffi.wasm_trap_t)()
        error = ffi.wasmtime_func_call(
            self._ptr,
            params_ptr,
            len(params),
            results_ptr,
            len(result_tys),
            byref(trap))
        if error:
            raise WasmtimeError._from_ptr(error)
        if trap:
            raise Trap._from_ptr(trap)

        results = []
        for i in range(0, len(result_tys)):
            results.append(Val(results_ptr[i]).value)
        if len(results) == 0:
            return None
        elif len(results) == 1:
            return results[0]
        else:
            return results

    def _as_extern(self) -&gt; &#34;pointer[ffi.wasm_extern_t]&#34;:
        return ffi.wasm_func_as_extern(self._ptr)

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_owner&#39;) and self._owner is None:
            ffi.wasm_func_delete(self._ptr)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.Func.param_arity"><code class="name">var <span class="ident">param_arity</span> : int</code></dt>
<dd>
<div class="desc"><p>Returns the number of parameters this function expects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def param_arity(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of parameters this function expects
    &#34;&#34;&#34;
    return ffi.wasm_func_param_arity(self._ptr)</code></pre>
</details>
</dd>
<dt id="wasmtime.Func.result_arity"><code class="name">var <span class="ident">result_arity</span> : int</code></dt>
<dd>
<div class="desc"><p>Returns the number of results this function produces</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def result_arity(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of results this function produces
    &#34;&#34;&#34;
    return ffi.wasm_func_result_arity(self._ptr)</code></pre>
</details>
</dd>
<dt id="wasmtime.Func.type"><code class="name">var <span class="ident">type</span> : wasmtime._types.FuncType</code></dt>
<dd>
<div class="desc"><p>Gets the type of this func as a <code><a title="wasmtime.FuncType" href="#wasmtime.FuncType">FuncType</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; FuncType:
    &#34;&#34;&#34;
    Gets the type of this func as a `FuncType`
    &#34;&#34;&#34;
    ptr = ffi.wasm_func_type(self._ptr)
    return FuncType._from_ptr(ptr, None)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.FuncType"><code class="flex name class">
<span>class <span class="ident">FuncType</span></span>
<span>(</span><span>params: List[wasmtime._types.ValType], results: List[wasmtime._types.ValType])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FuncType:
    def __init__(self, params: List[ValType], results: List[ValType]):
        for param in params:
            if not isinstance(param, ValType):
                raise TypeError(&#34;expected ValType&#34;)
        for result in results:
            if not isinstance(result, ValType):
                raise TypeError(&#34;expected ValType&#34;)

        params_ffi = ffi.wasm_valtype_vec_t()
        ffi.wasm_valtype_vec_new_uninitialized(byref(params_ffi), len(params))

        results_ffi = ffi.wasm_valtype_vec_t()
        for i, param in enumerate(params):
            params_ffi.data[i] = take_owned_valtype(param)

        ffi.wasm_valtype_vec_new_uninitialized(
            byref(results_ffi), len(results))
        for i, result in enumerate(results):
            results_ffi.data[i] = take_owned_valtype(result)
        ptr = ffi.wasm_functype_new(byref(params_ffi), byref(results_ffi))
        if not ptr:
            raise WasmtimeError(&#34;failed to allocate FuncType&#34;)
        self._ptr = ptr
        self._owner = None

    @classmethod
    def _from_ptr(cls, ptr: &#34;pointer[ffi.wasm_functype_t]&#34;, owner: Optional[Any]) -&gt; &#34;FuncType&#34;:
        ty: &#34;FuncType&#34; = cls.__new__(cls)
        if not isinstance(ptr, POINTER(ffi.wasm_functype_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        ty._ptr = ptr
        ty._owner = owner
        return ty

    @property
    def params(self) -&gt; List[&#34;ValType&#34;]:
        &#34;&#34;&#34;
        Returns the list of parameter types for this function type
        &#34;&#34;&#34;

        ptr = ffi.wasm_functype_params(self._ptr)
        return ValType._from_list(ptr, self)

    @property
    def results(self) -&gt; List[&#34;ValType&#34;]:
        &#34;&#34;&#34;
        Returns the list of result types for this function type
        &#34;&#34;&#34;

        ptr = ffi.wasm_functype_results(self._ptr)
        return ValType._from_list(ptr, self)

    def _as_extern(self) -&gt; &#34;pointer[ffi.wasm_externtype_t]&#34;:
        return ffi.wasm_functype_as_externtype_const(self._ptr)

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_owner&#39;) and self._owner is None:
            ffi.wasm_functype_delete(self._ptr)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.FuncType.params"><code class="name">var <span class="ident">params</span> : List[wasmtime._types.ValType]</code></dt>
<dd>
<div class="desc"><p>Returns the list of parameter types for this function type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def params(self) -&gt; List[&#34;ValType&#34;]:
    &#34;&#34;&#34;
    Returns the list of parameter types for this function type
    &#34;&#34;&#34;

    ptr = ffi.wasm_functype_params(self._ptr)
    return ValType._from_list(ptr, self)</code></pre>
</details>
</dd>
<dt id="wasmtime.FuncType.results"><code class="name">var <span class="ident">results</span> : List[wasmtime._types.ValType]</code></dt>
<dd>
<div class="desc"><p>Returns the list of result types for this function type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def results(self) -&gt; List[&#34;ValType&#34;]:
    &#34;&#34;&#34;
    Returns the list of result types for this function type
    &#34;&#34;&#34;

    ptr = ffi.wasm_functype_results(self._ptr)
    return ValType._from_list(ptr, self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.Global"><code class="flex name class">
<span>class <span class="ident">Global</span></span>
<span>(</span><span>store: wasmtime._store.Store, ty: wasmtime._types.GlobalType, val: Union[wasmtime._value.Val, int, float, NoneType, ForwardRef('<a title="wasmtime.Func" href="#wasmtime.Func">Func</a>'), Any])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Global:
    def __init__(self, store: Store, ty: GlobalType, val: IntoVal):
        if not isinstance(store, Store):
            raise TypeError(&#34;expected a Store&#34;)
        if not isinstance(ty, GlobalType):
            raise TypeError(&#34;expected a GlobalType&#34;)
        val = Val._convert(ty.content, val)
        ptr = POINTER(ffi.wasm_global_t)()
        error = ffi.wasmtime_global_new(
            store._ptr,
            ty._ptr,
            byref(val._unwrap_raw()),
            byref(ptr))
        if error:
            raise WasmtimeError._from_ptr(error)
        self._ptr = ptr
        self._owner = None

    @classmethod
    def _from_ptr(cls, ptr: &#34;pointer[ffi.wasm_global_t]&#34;, owner: Optional[Any]) -&gt; &#34;Global&#34;:
        ty: &#34;Global&#34; = cls.__new__(cls)
        if not isinstance(ptr, POINTER(ffi.wasm_global_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        ty._ptr = ptr
        ty._owner = owner
        return ty

    @property
    def type(self) -&gt; GlobalType:
        &#34;&#34;&#34;
        Gets the type of this global as a `GlobalType`
        &#34;&#34;&#34;

        ptr = ffi.wasm_global_type(self._ptr)
        return GlobalType._from_ptr(ptr, None)

    @property
    def value(self) -&gt; IntoVal:
        &#34;&#34;&#34;
        Gets the current value of this global

        Returns a native python type
        &#34;&#34;&#34;
        raw = ffi.wasm_val_t()
        ffi.wasm_global_get(self._ptr, byref(raw))
        val = Val(raw)
        if val.value:
            return val.value
        else:
            return val

    @value.setter
    def value(self, val: IntoVal) -&gt; None:
        &#34;&#34;&#34;
        Sets the value of this global to a new value
        &#34;&#34;&#34;
        val = Val._convert(self.type.content, val)
        error = ffi.wasmtime_global_set(self._ptr, byref(val._unwrap_raw()))
        if error:
            raise WasmtimeError._from_ptr(error)

    def _as_extern(self) -&gt; &#34;pointer[ffi.wasm_extern_t]&#34;:
        return ffi.wasm_global_as_extern(self._ptr)

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_owner&#39;) and self._owner is None:
            ffi.wasm_global_delete(self._ptr)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.Global.type"><code class="name">var <span class="ident">type</span> : wasmtime._types.GlobalType</code></dt>
<dd>
<div class="desc"><p>Gets the type of this global as a <code><a title="wasmtime.GlobalType" href="#wasmtime.GlobalType">GlobalType</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; GlobalType:
    &#34;&#34;&#34;
    Gets the type of this global as a `GlobalType`
    &#34;&#34;&#34;

    ptr = ffi.wasm_global_type(self._ptr)
    return GlobalType._from_ptr(ptr, None)</code></pre>
</details>
</dd>
<dt id="wasmtime.Global.value"><code class="name">var <span class="ident">value</span> : Union[wasmtime._value.Val, int, float, NoneType, ForwardRef('<a title="wasmtime.Func" href="#wasmtime.Func">Func</a>'), Any]</code></dt>
<dd>
<div class="desc"><p>Gets the current value of this global</p>
<p>Returns a native python type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(self) -&gt; IntoVal:
    &#34;&#34;&#34;
    Gets the current value of this global

    Returns a native python type
    &#34;&#34;&#34;
    raw = ffi.wasm_val_t()
    ffi.wasm_global_get(self._ptr, byref(raw))
    val = Val(raw)
    if val.value:
        return val.value
    else:
        return val</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.GlobalType"><code class="flex name class">
<span>class <span class="ident">GlobalType</span></span>
<span>(</span><span>valtype: wasmtime._types.ValType, mutable: bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GlobalType:
    def __init__(self, valtype: ValType, mutable: bool):
        if mutable:
            mutability = ffi.WASM_VAR
        else:
            mutability = ffi.WASM_CONST
        type_ptr = take_owned_valtype(valtype)
        ptr = ffi.wasm_globaltype_new(type_ptr, mutability)
        if ptr == 0:
            raise WasmtimeError(&#34;failed to allocate GlobalType&#34;)
        self._ptr = ptr
        self._owner = None

    @classmethod
    def _from_ptr(cls, ptr: &#34;pointer[ffi.wasm_globaltype_t]&#34;, owner: Optional[Any]) -&gt; &#34;GlobalType&#34;:
        ty: &#34;GlobalType&#34; = cls.__new__(cls)
        if not isinstance(ptr, POINTER(ffi.wasm_globaltype_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        ty._ptr = ptr
        ty._owner = owner
        return ty

    @property
    def content(self) -&gt; ValType:
        &#34;&#34;&#34;
        Returns the type this global contains
        &#34;&#34;&#34;

        ptr = ffi.wasm_globaltype_content(self._ptr)
        return ValType._from_ptr(ptr, self)

    @property
    def mutable(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns whether this global is mutable or not
        &#34;&#34;&#34;
        val = ffi.wasm_globaltype_mutability(self._ptr)
        return val == ffi.WASM_VAR.value

    def _as_extern(self) -&gt; &#34;pointer[ffi.wasm_externtype_t]&#34;:
        return ffi.wasm_globaltype_as_externtype_const(self._ptr)

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_owner&#39;) and self._owner is None:
            ffi.wasm_globaltype_delete(self._ptr)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.GlobalType.content"><code class="name">var <span class="ident">content</span> : wasmtime._types.ValType</code></dt>
<dd>
<div class="desc"><p>Returns the type this global contains</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def content(self) -&gt; ValType:
    &#34;&#34;&#34;
    Returns the type this global contains
    &#34;&#34;&#34;

    ptr = ffi.wasm_globaltype_content(self._ptr)
    return ValType._from_ptr(ptr, self)</code></pre>
</details>
</dd>
<dt id="wasmtime.GlobalType.mutable"><code class="name">var <span class="ident">mutable</span> : bool</code></dt>
<dd>
<div class="desc"><p>Returns whether this global is mutable or not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mutable(self) -&gt; bool:
    &#34;&#34;&#34;
    Returns whether this global is mutable or not
    &#34;&#34;&#34;
    val = ffi.wasm_globaltype_mutability(self._ptr)
    return val == ffi.WASM_VAR.value</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.ImportType"><code class="flex name class">
<span>class <span class="ident">ImportType</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImportType:
    _ptr: &#34;pointer[ffi.wasm_importtype_t]&#34;
    _owner: Optional[Any]

    @classmethod
    def _from_ptr(cls, ptr: &#34;pointer[ffi.wasm_importtype_t]&#34;, owner: Optional[Any]) -&gt; &#34;ImportType&#34;:
        ty: &#34;ImportType&#34; = cls.__new__(cls)
        if not isinstance(ptr, POINTER(ffi.wasm_importtype_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        ty._ptr = ptr
        ty._owner = owner
        return ty

    @property
    def module(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the module this import type refers to
        &#34;&#34;&#34;

        return ffi.to_str(ffi.wasm_importtype_module(self._ptr).contents)

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the name in the modulethis import type refers to
        &#34;&#34;&#34;
        return ffi.to_str(ffi.wasm_importtype_name(self._ptr).contents)

    @property
    def type(self) -&gt; &#34;AsExternType&#34;:
        &#34;&#34;&#34;
        Returns the type that this import refers to
        &#34;&#34;&#34;
        ptr = ffi.wasm_importtype_type(self._ptr)
        return wrap_externtype(ptr, self._owner or self)

    def __del__(self) -&gt; None:
        if self._owner is None:
            ffi.wasm_importtype_delete(self._ptr)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.ImportType.module"><code class="name">var <span class="ident">module</span> : str</code></dt>
<dd>
<div class="desc"><p>Returns the module this import type refers to</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def module(self) -&gt; str:
    &#34;&#34;&#34;
    Returns the module this import type refers to
    &#34;&#34;&#34;

    return ffi.to_str(ffi.wasm_importtype_module(self._ptr).contents)</code></pre>
</details>
</dd>
<dt id="wasmtime.ImportType.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>Returns the name in the modulethis import type refers to</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;
    Returns the name in the modulethis import type refers to
    &#34;&#34;&#34;
    return ffi.to_str(ffi.wasm_importtype_name(self._ptr).contents)</code></pre>
</details>
</dd>
<dt id="wasmtime.ImportType.type"><code class="name">var <span class="ident">type</span> : Union[wasmtime._types.FuncType, wasmtime._types.TableType, wasmtime._types.MemoryType, wasmtime._types.GlobalType]</code></dt>
<dd>
<div class="desc"><p>Returns the type that this import refers to</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; &#34;AsExternType&#34;:
    &#34;&#34;&#34;
    Returns the type that this import refers to
    &#34;&#34;&#34;
    ptr = ffi.wasm_importtype_type(self._ptr)
    return wrap_externtype(ptr, self._owner or self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.Instance"><code class="flex name class">
<span>class <span class="ident">Instance</span></span>
<span>(</span><span>store: wasmtime._store.Store, module: wasmtime._module.Module, imports: Sequence[Union[ForwardRef('<a title="wasmtime.Func" href="#wasmtime.Func">Func</a>'), ForwardRef('<a title="wasmtime.Table" href="#wasmtime.Table">Table</a>'), ForwardRef('<a title="wasmtime.Memory" href="#wasmtime.Memory">Memory</a>'), ForwardRef('<a title="wasmtime.Global" href="#wasmtime.Global">Global</a>')]])</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new instance by instantiating the <code>module</code> given with the
<code>imports</code> into the <code>store</code> provided.</p>
<p>The <code>store</code> must have type <code><a title="wasmtime.Store" href="#wasmtime.Store">Store</a></code>, the <code>module</code> must have type
<code><a title="wasmtime.Module" href="#wasmtime.Module">Module</a></code>, and the <code>imports</code> must be an iterable of external values,
either <code>Extern</code>, <code><a title="wasmtime.Func" href="#wasmtime.Func">Func</a></code>, <code><a title="wasmtime.Table" href="#wasmtime.Table">Table</a></code>, <code><a title="wasmtime.Memory" href="#wasmtime.Memory">Memory</a></code>, or <code><a title="wasmtime.Global" href="#wasmtime.Global">Global</a></code>.</p>
<p>Raises an error if instantiation fails (e.g. linking or trap) and
otherwise initializes the new instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Instance:
    _ptr: &#34;pointer[ffi.wasm_instance_t]&#34;
    _module: Module
    _exports: Optional[&#34;InstanceExports&#34;]

    def __init__(self, store: Store, module: Module, imports: Sequence[AsExtern]):
        &#34;&#34;&#34;
        Creates a new instance by instantiating the `module` given with the
        `imports` into the `store` provided.

        The `store` must have type `Store`, the `module` must have type
        `Module`, and the `imports` must be an iterable of external values,
        either `Extern`, `Func`, `Table`, `Memory`, or `Global`.

        Raises an error if instantiation fails (e.g. linking or trap) and
        otherwise initializes the new instance.
        &#34;&#34;&#34;

        if not isinstance(store, Store):
            raise TypeError(&#34;expected a Store&#34;)
        if not isinstance(module, Module):
            raise TypeError(&#34;expected a Module&#34;)

        imports_ptr = (POINTER(ffi.wasm_extern_t) * len(imports))()
        for i, val in enumerate(imports):
            imports_ptr[i] = get_extern_ptr(val)

        instance = POINTER(ffi.wasm_instance_t)()
        trap = POINTER(ffi.wasm_trap_t)()
        error = ffi.wasmtime_instance_new(
            store._ptr,
            module._ptr,
            imports_ptr,
            len(imports),
            byref(instance),
            byref(trap))
        if error:
            raise WasmtimeError._from_ptr(error)
        if trap:
            raise Trap._from_ptr(trap)
        self._ptr = instance
        self._module = module
        self._exports = None

    @classmethod
    def _from_ptr(cls, ptr: pointer, module: Module) -&gt; &#34;Instance&#34;:
        ty: &#34;Instance&#34; = cls.__new__(cls)
        if not isinstance(ptr, POINTER(ffi.wasm_instance_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        ty._ptr = ptr
        ty._module = module
        ty._exports = None
        return ty

    @property
    def exports(self) -&gt; &#34;InstanceExports&#34;:
        &#34;&#34;&#34;
        Returns the exports of this module

        The returned type can be indexed both with integers and with strings for
        names of exports.
        &#34;&#34;&#34;
        if self._exports is None:
            externs = ExternTypeList()
            ffi.wasm_instance_exports(self._ptr, byref(externs.vec))
            extern_list = []
            for i in range(0, externs.vec.size):
                extern_list.append(wrap_extern(externs.vec.data[i], externs))
            self._exports = InstanceExports(extern_list, self._module)
        return self._exports

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_ptr&#39;):
            ffi.wasm_instance_delete(self._ptr)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.Instance.exports"><code class="name">var <span class="ident">exports</span> : wasmtime._instance.InstanceExports</code></dt>
<dd>
<div class="desc"><p>Returns the exports of this module</p>
<p>The returned type can be indexed both with integers and with strings for
names of exports.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def exports(self) -&gt; &#34;InstanceExports&#34;:
    &#34;&#34;&#34;
    Returns the exports of this module

    The returned type can be indexed both with integers and with strings for
    names of exports.
    &#34;&#34;&#34;
    if self._exports is None:
        externs = ExternTypeList()
        ffi.wasm_instance_exports(self._ptr, byref(externs.vec))
        extern_list = []
        for i in range(0, externs.vec.size):
            extern_list.append(wrap_extern(externs.vec.data[i], externs))
        self._exports = InstanceExports(extern_list, self._module)
    return self._exports</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.Limits"><code class="flex name class">
<span>class <span class="ident">Limits</span></span>
<span>(</span><span>min: int, max: Union[int, NoneType])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Limits:
    def __init__(self, min: int, max: Optional[int]):
        self.min = min
        self.max = max

    def __ffi__(self) -&gt; ffi.wasm_limits_t:
        max = self.max
        if max is None:
            max = 0xffffffff
        return ffi.wasm_limits_t(self.min, max)

    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, Limits):
            return False
        return self.min == other.min and self.max == other.max

    @classmethod
    def _from_ffi(cls, val: &#39;pointer[ffi.wasm_limits_t]&#39;) -&gt; &#34;Limits&#34;:
        min = val.contents.min
        max = val.contents.max
        if max == 0xffffffff:
            max = None
        return Limits(min, max)</code></pre>
</details>
</dd>
<dt id="wasmtime.Linker"><code class="flex name class">
<span>class <span class="ident">Linker</span></span>
<span>(</span><span>store: wasmtime._store.Store)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Linker:
    def __init__(self, store: Store):
        if not isinstance(store, Store):
            raise TypeError(&#34;expected a Store&#34;)
        self._ptr = ffi.wasmtime_linker_new(store._ptr)
        self.store = store

    @setter_property
    def allow_shadowing(self, allow: bool) -&gt; None:
        &#34;&#34;&#34;
        Configures whether definitions are allowed to shadow one another within
        this linker
        &#34;&#34;&#34;
        if not isinstance(allow, bool):
            raise TypeError(&#34;expected a boolean&#34;)
        ffi.wasmtime_linker_allow_shadowing(self._ptr, allow)

    def define(self, module: str, name: str, item: AsExtern) -&gt; None:
        raw_item = get_extern_ptr(item)
        module_raw = ffi.str_to_name(module)
        name_raw = ffi.str_to_name(name)
        error = ffi.wasmtime_linker_define(
            self._ptr,
            byref(module_raw),
            byref(name_raw),
            raw_item)
        if error:
            raise WasmtimeError._from_ptr(error)

    def define_instance(self, name: str, instance: Instance) -&gt; None:
        if not isinstance(instance, Instance):
            raise TypeError(&#34;expected an `Instance`&#34;)
        name_raw = ffi.str_to_name(name)
        error = ffi.wasmtime_linker_define_instance(self._ptr, byref(name_raw),
                                                    instance._ptr)
        if error:
            raise WasmtimeError._from_ptr(error)

    def define_wasi(self, instance: WasiInstance) -&gt; None:
        if not isinstance(instance, WasiInstance):
            raise TypeError(&#34;expected an `WasiInstance`&#34;)
        error = ffi.wasmtime_linker_define_wasi(self._ptr, instance._ptr)
        if error:
            raise WasmtimeError._from_ptr(error)

    def instantiate(self, module: Module) -&gt; Instance:
        if not isinstance(module, Module):
            raise TypeError(&#34;expected a `Module`&#34;)
        trap = POINTER(ffi.wasm_trap_t)()
        instance = POINTER(ffi.wasm_instance_t)()
        error = ffi.wasmtime_linker_instantiate(
            self._ptr, module._ptr, byref(instance), byref(trap))
        if error:
            raise WasmtimeError._from_ptr(error)
        if trap:
            raise Trap._from_ptr(trap)
        return Instance._from_ptr(instance, module)

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_ptr&#39;):
            ffi.wasmtime_linker_delete(self._ptr)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.Linker.allow_shadowing"><code class="name">var <span class="ident">allow_shadowing</span></code></dt>
<dd>
<div class="desc"><p>Configures whether definitions are allowed to shadow one another within
this linker</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wasmtime.Linker.define"><code class="name flex">
<span>def <span class="ident">define</span></span>(<span>self, module: str, name: str, item: Union[ForwardRef('<a title="wasmtime.Func" href="#wasmtime.Func">Func</a>'), ForwardRef('<a title="wasmtime.Table" href="#wasmtime.Table">Table</a>'), ForwardRef('<a title="wasmtime.Memory" href="#wasmtime.Memory">Memory</a>'), ForwardRef('<a title="wasmtime.Global" href="#wasmtime.Global">Global</a>')])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define(self, module: str, name: str, item: AsExtern) -&gt; None:
    raw_item = get_extern_ptr(item)
    module_raw = ffi.str_to_name(module)
    name_raw = ffi.str_to_name(name)
    error = ffi.wasmtime_linker_define(
        self._ptr,
        byref(module_raw),
        byref(name_raw),
        raw_item)
    if error:
        raise WasmtimeError._from_ptr(error)</code></pre>
</details>
</dd>
<dt id="wasmtime.Linker.define_instance"><code class="name flex">
<span>def <span class="ident">define_instance</span></span>(<span>self, name: str, instance: wasmtime._instance.Instance) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define_instance(self, name: str, instance: Instance) -&gt; None:
    if not isinstance(instance, Instance):
        raise TypeError(&#34;expected an `Instance`&#34;)
    name_raw = ffi.str_to_name(name)
    error = ffi.wasmtime_linker_define_instance(self._ptr, byref(name_raw),
                                                instance._ptr)
    if error:
        raise WasmtimeError._from_ptr(error)</code></pre>
</details>
</dd>
<dt id="wasmtime.Linker.define_wasi"><code class="name flex">
<span>def <span class="ident">define_wasi</span></span>(<span>self, instance: wasmtime._wasi.WasiInstance) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define_wasi(self, instance: WasiInstance) -&gt; None:
    if not isinstance(instance, WasiInstance):
        raise TypeError(&#34;expected an `WasiInstance`&#34;)
    error = ffi.wasmtime_linker_define_wasi(self._ptr, instance._ptr)
    if error:
        raise WasmtimeError._from_ptr(error)</code></pre>
</details>
</dd>
<dt id="wasmtime.Linker.instantiate"><code class="name flex">
<span>def <span class="ident">instantiate</span></span>(<span>self, module: wasmtime._module.Module) ‑> wasmtime._instance.Instance</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def instantiate(self, module: Module) -&gt; Instance:
    if not isinstance(module, Module):
        raise TypeError(&#34;expected a `Module`&#34;)
    trap = POINTER(ffi.wasm_trap_t)()
    instance = POINTER(ffi.wasm_instance_t)()
    error = ffi.wasmtime_linker_instantiate(
        self._ptr, module._ptr, byref(instance), byref(trap))
    if error:
        raise WasmtimeError._from_ptr(error)
    if trap:
        raise Trap._from_ptr(trap)
    return Instance._from_ptr(instance, module)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.Memory"><code class="flex name class">
<span>class <span class="ident">Memory</span></span>
<span>(</span><span>store: wasmtime._store.Store, ty: wasmtime._types.MemoryType)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new memory in <code>store</code> with the given <code>ty</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Memory:
    def __init__(self, store: Store, ty: MemoryType):
        &#34;&#34;&#34;
        Creates a new memory in `store` with the given `ty`
        &#34;&#34;&#34;

        if not isinstance(store, Store):
            raise TypeError(&#34;expected a Store&#34;)
        if not isinstance(ty, MemoryType):
            raise TypeError(&#34;expected a MemoryType&#34;)
        ptr = ffi.wasm_memory_new(store._ptr, ty._ptr)
        if not ptr:
            raise WasmtimeError(&#34;failed to create memory&#34;)
        self._ptr = ptr
        self._owner = None

    @classmethod
    def _from_ptr(cls, ptr: &#34;pointer[ffi.wasm_memory_t]&#34;, owner: Optional[Any]) -&gt; &#34;Memory&#34;:
        ty: &#34;Memory&#34; = cls.__new__(cls)
        if not isinstance(ptr, POINTER(ffi.wasm_memory_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        ty._ptr = ptr
        ty._owner = owner
        return ty

    @property
    def type(self) -&gt; MemoryType:
        &#34;&#34;&#34;
        Gets the type of this memory as a `MemoryType`
        &#34;&#34;&#34;

        ptr = ffi.wasm_memory_type(self._ptr)
        return MemoryType._from_ptr(ptr, None)

    def grow(self, delta: int) -&gt; bool:
        &#34;&#34;&#34;
        Grows this memory by the given number of pages
        &#34;&#34;&#34;

        if not isinstance(delta, int):
            raise TypeError(&#34;expected an integer&#34;)
        if delta &lt; 0:
            raise WasmtimeError(&#34;cannot grow by negative amount&#34;)
        ok = ffi.wasm_memory_grow(self._ptr, delta)
        if ok:
            return True
        else:
            return False

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the size, in WebAssembly pages, of this memory.
        &#34;&#34;&#34;

        return ffi.wasm_memory_size(self._ptr)

    @property
    def data_ptr(self) -&gt; &#34;pointer[c_ubyte]&#34;:
        &#34;&#34;&#34;
        Returns the raw pointer in memory where this wasm memory lives.

        Remember that all accesses to wasm memory should be bounds-checked
        against the `data_len` method.
        &#34;&#34;&#34;
        return ffi.wasm_memory_data(self._ptr)

    @property
    def data_len(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the raw byte length of this memory.
        &#34;&#34;&#34;

        return ffi.wasm_memory_data_size(self._ptr)

    def _as_extern(self) -&gt; &#34;pointer[ffi.wasm_extern_t]&#34;:
        return ffi.wasm_memory_as_extern(self._ptr)

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_owner&#39;) and self._owner is None:
            ffi.wasm_memory_delete(self._ptr)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.Memory.data_len"><code class="name">var <span class="ident">data_len</span> : int</code></dt>
<dd>
<div class="desc"><p>Returns the raw byte length of this memory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_len(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the raw byte length of this memory.
    &#34;&#34;&#34;

    return ffi.wasm_memory_data_size(self._ptr)</code></pre>
</details>
</dd>
<dt id="wasmtime.Memory.data_ptr"><code class="name">var <span class="ident">data_ptr</span> : 'pointer[c_ubyte]'</code></dt>
<dd>
<div class="desc"><p>Returns the raw pointer in memory where this wasm memory lives.</p>
<p>Remember that all accesses to wasm memory should be bounds-checked
against the <code>data_len</code> method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_ptr(self) -&gt; &#34;pointer[c_ubyte]&#34;:
    &#34;&#34;&#34;
    Returns the raw pointer in memory where this wasm memory lives.

    Remember that all accesses to wasm memory should be bounds-checked
    against the `data_len` method.
    &#34;&#34;&#34;
    return ffi.wasm_memory_data(self._ptr)</code></pre>
</details>
</dd>
<dt id="wasmtime.Memory.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Returns the size, in WebAssembly pages, of this memory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the size, in WebAssembly pages, of this memory.
    &#34;&#34;&#34;

    return ffi.wasm_memory_size(self._ptr)</code></pre>
</details>
</dd>
<dt id="wasmtime.Memory.type"><code class="name">var <span class="ident">type</span> : wasmtime._types.MemoryType</code></dt>
<dd>
<div class="desc"><p>Gets the type of this memory as a <code><a title="wasmtime.MemoryType" href="#wasmtime.MemoryType">MemoryType</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; MemoryType:
    &#34;&#34;&#34;
    Gets the type of this memory as a `MemoryType`
    &#34;&#34;&#34;

    ptr = ffi.wasm_memory_type(self._ptr)
    return MemoryType._from_ptr(ptr, None)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wasmtime.Memory.grow"><code class="name flex">
<span>def <span class="ident">grow</span></span>(<span>self, delta: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Grows this memory by the given number of pages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grow(self, delta: int) -&gt; bool:
    &#34;&#34;&#34;
    Grows this memory by the given number of pages
    &#34;&#34;&#34;

    if not isinstance(delta, int):
        raise TypeError(&#34;expected an integer&#34;)
    if delta &lt; 0:
        raise WasmtimeError(&#34;cannot grow by negative amount&#34;)
    ok = ffi.wasm_memory_grow(self._ptr, delta)
    if ok:
        return True
    else:
        return False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.MemoryType"><code class="flex name class">
<span>class <span class="ident">MemoryType</span></span>
<span>(</span><span>limits: wasmtime._types.Limits)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MemoryType:
    def __init__(self, limits: Limits):
        if not isinstance(limits, Limits):
            raise TypeError(&#34;expected Limits&#34;)
        ptr = ffi.wasm_memorytype_new(byref(limits.__ffi__()))
        if not ptr:
            raise WasmtimeError(&#34;failed to allocate MemoryType&#34;)
        self._ptr = ptr
        self._owner = None

    @classmethod
    def _from_ptr(cls, ptr: &#34;pointer[ffi.wasm_memorytype_t]&#34;, owner: Optional[Any]) -&gt; &#34;MemoryType&#34;:
        ty: &#34;MemoryType&#34; = cls.__new__(cls)
        if not isinstance(ptr, POINTER(ffi.wasm_memorytype_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        ty._ptr = ptr
        ty._owner = owner
        return ty

    @property
    def limits(self) -&gt; Limits:
        &#34;&#34;&#34;
        Returns the limits on the size of this table
        &#34;&#34;&#34;
        val = ffi.wasm_memorytype_limits(self._ptr)
        return Limits._from_ffi(val)

    def _as_extern(self) -&gt; &#34;pointer[ffi.wasm_externtype_t]&#34;:
        return ffi.wasm_memorytype_as_externtype_const(self._ptr)

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_owner&#39;) and self._owner is None:
            ffi.wasm_memorytype_delete(self._ptr)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.MemoryType.limits"><code class="name">var <span class="ident">limits</span> : wasmtime._types.Limits</code></dt>
<dd>
<div class="desc"><p>Returns the limits on the size of this table</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def limits(self) -&gt; Limits:
    &#34;&#34;&#34;
    Returns the limits on the size of this table
    &#34;&#34;&#34;
    val = ffi.wasm_memorytype_limits(self._ptr)
    return Limits._from_ffi(val)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.Module"><code class="flex name class">
<span>class <span class="ident">Module</span></span>
<span>(</span><span>engine: wasmtime._engine.Engine, wasm: Union[str, bytes])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Module:
    @classmethod
    def from_file(cls, engine: Engine, path: str) -&gt; &#34;Module&#34;:
        &#34;&#34;&#34;
        Compiles and creates a new `Module` by reading the file at `path` and
        then delegating to the `Module` constructor.
        &#34;&#34;&#34;

        with open(path, &#34;rb&#34;) as f:
            contents = f.read()
        return cls(engine, contents)

    def __init__(self, engine: Engine, wasm: typing.Union[str, bytes]):
        if not isinstance(engine, Engine):
            raise TypeError(&#34;expected an Engine&#34;)

        # If this looks like a string, parse it as the text format. Note that
        # in python 2 strings and bytes are basically the same, so we skip this
        # if the first byte in the string is 0, meaning this is actually a wasm
        # module.
        if isinstance(wasm, str) and len(wasm) &gt; 0 and ord(wasm[0]) != 0:
            wasm = wat2wasm(wasm)
        if isinstance(wasm, bytes) and len(wasm) &gt; 0 and wasm[0] != 0:
            wasm = wat2wasm(wasm)

        if not isinstance(wasm, (bytes, bytearray)):
            raise TypeError(&#34;expected wasm bytes&#34;)

        # TODO: can the copy be avoided here? I can&#39;t for the life of me
        # figure this out.
        c_ty = c_uint8 * len(wasm)
        binary = ffi.wasm_byte_vec_t(len(wasm), c_ty.from_buffer_copy(wasm))
        ptr = POINTER(ffi.wasm_module_t)()
        error = ffi.wasmtime_module_new(engine._ptr, byref(binary), byref(ptr))
        if error:
            raise WasmtimeError._from_ptr(error)
        self._ptr = ptr
        self.engine = engine

    @classmethod
    def _from_ptr(cls, ptr: &#34;pointer[ffi.wasm_module_t]&#34;, engine: Engine) -&gt; &#34;Module&#34;:
        ty: &#34;Module&#34; = cls.__new__(cls)
        if not isinstance(ptr, POINTER(ffi.wasm_module_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        ty._ptr = ptr
        ty.engine = engine
        return ty

    @classmethod
    def deserialize(cls, engine: Engine, encoded: typing.Union[bytes, bytearray]) -&gt; &#39;Module&#39;:
        &#34;&#34;&#34;
        Deserializes bytes previously created by `Module.serialize`.

        This constructor for `Module` will deserialize bytes previously created
        by a serialized module. This will only succeed if the bytes were
        previously created by the same version of `wasmtime` as well as the
        same configuration within `Engine`.
        &#34;&#34;&#34;

        if not isinstance(engine, Engine):
            raise TypeError(&#34;expected an Engine&#34;)
        if not isinstance(encoded, (bytes, bytearray)):
            raise TypeError(&#34;expected bytes&#34;)

        # TODO: can the copy be avoided here? I can&#39;t for the life of me
        # figure this out.
        c_ty = c_uint8 * len(encoded)
        binary = ffi.wasm_byte_vec_t(len(encoded), c_ty.from_buffer_copy(encoded))
        ptr = POINTER(ffi.wasm_module_t)()
        error = ffi.wasmtime_module_deserialize(engine._ptr, byref(binary), byref(ptr))
        if error:
            raise WasmtimeError._from_ptr(error)
        ret: &#34;Module&#34; = cls.__new__(cls)
        ret._ptr = ptr
        ret.engine = engine
        return ret

    @classmethod
    def validate(cls, store: Store, wasm: typing.Union[bytes, bytearray]) -&gt; None:
        &#34;&#34;&#34;
        Validates whether the list of bytes `wasm` provided is a valid
        WebAssembly binary given the configuration in `store`

        Raises a `WasmtimeError` if the wasm isn&#39;t valid.
        &#34;&#34;&#34;

        if not isinstance(store, Store):
            raise TypeError(&#34;expected a Store&#34;)
        if not isinstance(wasm, (bytes, bytearray)):
            raise TypeError(&#34;expected wasm bytes&#34;)

        # TODO: can the copy be avoided here? I can&#39;t for the life of me
        # figure this out.
        c_ty = c_uint8 * len(wasm)
        binary = ffi.wasm_byte_vec_t(len(wasm), c_ty.from_buffer_copy(wasm))
        error = ffi.wasmtime_module_validate(store._ptr, byref(binary))
        if error:
            raise WasmtimeError._from_ptr(error)

    @property
    def imports(self) -&gt; typing.List[ImportType]:
        &#34;&#34;&#34;
        Returns the types of imports that this module has
        &#34;&#34;&#34;

        imports = ImportTypeList()
        ffi.wasm_module_imports(self._ptr, byref(imports.vec))
        ret = []
        for i in range(0, imports.vec.size):
            ret.append(ImportType._from_ptr(imports.vec.data[i], imports))
        return ret

    @property
    def exports(self) -&gt; typing.List[ExportType]:
        &#34;&#34;&#34;
        Returns the types of the exports that this module has
        &#34;&#34;&#34;

        exports = ExportTypeList()
        ffi.wasm_module_exports(self._ptr, byref(exports.vec))
        ret = []
        for i in range(0, exports.vec.size):
            ret.append(ExportType._from_ptr(exports.vec.data[i], exports))
        return ret

    def serialize(self) -&gt; bytearray:
        &#34;&#34;&#34;
        Serializes this module to a binary representation.

        This method will serialize this module to an in-memory byte array which
        can be cached and later passed to `Module.deserialize` to recreate this
        module.
        &#34;&#34;&#34;
        raw = ffi.wasm_byte_vec_t()
        err = ffi.wasmtime_module_serialize(self._ptr, byref(raw))
        if err:
            raise WasmtimeError._from_ptr(err)
        ret = ffi.to_bytes(raw)
        ffi.wasm_byte_vec_delete(byref(raw))
        return ret</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="wasmtime.Module.deserialize"><code class="name flex">
<span>def <span class="ident">deserialize</span></span>(<span>engine: wasmtime._engine.Engine, encoded: Union[bytes, bytearray]) ‑> wasmtime._module.Module</span>
</code></dt>
<dd>
<div class="desc"><p>Deserializes bytes previously created by <code><a title="wasmtime.Module.serialize" href="#wasmtime.Module.serialize">Module.serialize()</a></code>.</p>
<p>This constructor for <code><a title="wasmtime.Module" href="#wasmtime.Module">Module</a></code> will deserialize bytes previously created
by a serialized module. This will only succeed if the bytes were
previously created by the same version of <code><a title="wasmtime" href="#wasmtime">wasmtime</a></code> as well as the
same configuration within <code><a title="wasmtime.Engine" href="#wasmtime.Engine">Engine</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def deserialize(cls, engine: Engine, encoded: typing.Union[bytes, bytearray]) -&gt; &#39;Module&#39;:
    &#34;&#34;&#34;
    Deserializes bytes previously created by `Module.serialize`.

    This constructor for `Module` will deserialize bytes previously created
    by a serialized module. This will only succeed if the bytes were
    previously created by the same version of `wasmtime` as well as the
    same configuration within `Engine`.
    &#34;&#34;&#34;

    if not isinstance(engine, Engine):
        raise TypeError(&#34;expected an Engine&#34;)
    if not isinstance(encoded, (bytes, bytearray)):
        raise TypeError(&#34;expected bytes&#34;)

    # TODO: can the copy be avoided here? I can&#39;t for the life of me
    # figure this out.
    c_ty = c_uint8 * len(encoded)
    binary = ffi.wasm_byte_vec_t(len(encoded), c_ty.from_buffer_copy(encoded))
    ptr = POINTER(ffi.wasm_module_t)()
    error = ffi.wasmtime_module_deserialize(engine._ptr, byref(binary), byref(ptr))
    if error:
        raise WasmtimeError._from_ptr(error)
    ret: &#34;Module&#34; = cls.__new__(cls)
    ret._ptr = ptr
    ret.engine = engine
    return ret</code></pre>
</details>
</dd>
<dt id="wasmtime.Module.from_file"><code class="name flex">
<span>def <span class="ident">from_file</span></span>(<span>engine: wasmtime._engine.Engine, path: str) ‑> wasmtime._module.Module</span>
</code></dt>
<dd>
<div class="desc"><p>Compiles and creates a new <code><a title="wasmtime.Module" href="#wasmtime.Module">Module</a></code> by reading the file at <code>path</code> and
then delegating to the <code><a title="wasmtime.Module" href="#wasmtime.Module">Module</a></code> constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_file(cls, engine: Engine, path: str) -&gt; &#34;Module&#34;:
    &#34;&#34;&#34;
    Compiles and creates a new `Module` by reading the file at `path` and
    then delegating to the `Module` constructor.
    &#34;&#34;&#34;

    with open(path, &#34;rb&#34;) as f:
        contents = f.read()
    return cls(engine, contents)</code></pre>
</details>
</dd>
<dt id="wasmtime.Module.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>store: wasmtime._store.Store, wasm: Union[bytes, bytearray]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Validates whether the list of bytes <code>wasm</code> provided is a valid
WebAssembly binary given the configuration in <code>store</code></p>
<p>Raises a <code><a title="wasmtime.WasmtimeError" href="#wasmtime.WasmtimeError">WasmtimeError</a></code> if the wasm isn't valid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def validate(cls, store: Store, wasm: typing.Union[bytes, bytearray]) -&gt; None:
    &#34;&#34;&#34;
    Validates whether the list of bytes `wasm` provided is a valid
    WebAssembly binary given the configuration in `store`

    Raises a `WasmtimeError` if the wasm isn&#39;t valid.
    &#34;&#34;&#34;

    if not isinstance(store, Store):
        raise TypeError(&#34;expected a Store&#34;)
    if not isinstance(wasm, (bytes, bytearray)):
        raise TypeError(&#34;expected wasm bytes&#34;)

    # TODO: can the copy be avoided here? I can&#39;t for the life of me
    # figure this out.
    c_ty = c_uint8 * len(wasm)
    binary = ffi.wasm_byte_vec_t(len(wasm), c_ty.from_buffer_copy(wasm))
    error = ffi.wasmtime_module_validate(store._ptr, byref(binary))
    if error:
        raise WasmtimeError._from_ptr(error)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.Module.exports"><code class="name">var <span class="ident">exports</span> : List[wasmtime._types.ExportType]</code></dt>
<dd>
<div class="desc"><p>Returns the types of the exports that this module has</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def exports(self) -&gt; typing.List[ExportType]:
    &#34;&#34;&#34;
    Returns the types of the exports that this module has
    &#34;&#34;&#34;

    exports = ExportTypeList()
    ffi.wasm_module_exports(self._ptr, byref(exports.vec))
    ret = []
    for i in range(0, exports.vec.size):
        ret.append(ExportType._from_ptr(exports.vec.data[i], exports))
    return ret</code></pre>
</details>
</dd>
<dt id="wasmtime.Module.imports"><code class="name">var <span class="ident">imports</span> : List[wasmtime._types.ImportType]</code></dt>
<dd>
<div class="desc"><p>Returns the types of imports that this module has</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def imports(self) -&gt; typing.List[ImportType]:
    &#34;&#34;&#34;
    Returns the types of imports that this module has
    &#34;&#34;&#34;

    imports = ImportTypeList()
    ffi.wasm_module_imports(self._ptr, byref(imports.vec))
    ret = []
    for i in range(0, imports.vec.size):
        ret.append(ImportType._from_ptr(imports.vec.data[i], imports))
    return ret</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wasmtime.Module.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self) ‑> bytearray</span>
</code></dt>
<dd>
<div class="desc"><p>Serializes this module to a binary representation.</p>
<p>This method will serialize this module to an in-memory byte array which
can be cached and later passed to <code><a title="wasmtime.Module.deserialize" href="#wasmtime.Module.deserialize">Module.deserialize()</a></code> to recreate this
module.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self) -&gt; bytearray:
    &#34;&#34;&#34;
    Serializes this module to a binary representation.

    This method will serialize this module to an in-memory byte array which
    can be cached and later passed to `Module.deserialize` to recreate this
    module.
    &#34;&#34;&#34;
    raw = ffi.wasm_byte_vec_t()
    err = ffi.wasmtime_module_serialize(self._ptr, byref(raw))
    if err:
        raise WasmtimeError._from_ptr(err)
    ret = ffi.to_bytes(raw)
    ffi.wasm_byte_vec_delete(byref(raw))
    return ret</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.Store"><code class="flex name class">
<span>class <span class="ident">Store</span></span>
<span>(</span><span>engine: wasmtime._engine.Engine = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Store:
    _ptr: &#34;pointer[ffi.wasm_store_t]&#34;

    def __init__(self, engine: Engine = None):
        if engine is None:
            engine = Engine()
        elif not isinstance(engine, Engine):
            raise TypeError(&#34;expected an Engine&#34;)
        self._ptr = ffi.wasm_store_new(engine._ptr)
        self.engine = engine

    def interrupt_handle(self) -&gt; &#34;InterruptHandle&#34;:
        &#34;&#34;&#34;
        Creates a new interrupt handle through which execution of wasm can be
        interrupted.

        Raises a `WasmtimeError` if this store&#39;s configuration has not been
        configured to enable interruption.

        For more information about this be sure to consult the Rust documentation:
        https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Store.html#method.interrupt_handle
        &#34;&#34;&#34;

        return InterruptHandle(self)

    def gc(self) -&gt; None:
        &#34;&#34;&#34;
        Runs a GC over `externref` values that have been passed into this Store,
        cleaning out anything that is no longer referenced.

        This is not required to be run manually, but can be done so if you&#39;d
        like more precise control over when unreferenced `externref` values are
        deallocated.
        &#34;&#34;&#34;
        ffi.wasmtime_store_gc(self._ptr)

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_ptr&#39;):
            ffi.wasm_store_delete(self._ptr)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="wasmtime.Store.gc"><code class="name flex">
<span>def <span class="ident">gc</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Runs a GC over <code>externref</code> values that have been passed into this Store,
cleaning out anything that is no longer referenced.</p>
<p>This is not required to be run manually, but can be done so if you'd
like more precise control over when unreferenced <code>externref</code> values are
deallocated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gc(self) -&gt; None:
    &#34;&#34;&#34;
    Runs a GC over `externref` values that have been passed into this Store,
    cleaning out anything that is no longer referenced.

    This is not required to be run manually, but can be done so if you&#39;d
    like more precise control over when unreferenced `externref` values are
    deallocated.
    &#34;&#34;&#34;
    ffi.wasmtime_store_gc(self._ptr)</code></pre>
</details>
</dd>
<dt id="wasmtime.Store.interrupt_handle"><code class="name flex">
<span>def <span class="ident">interrupt_handle</span></span>(<span>self) ‑> wasmtime._store.InterruptHandle</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new interrupt handle through which execution of wasm can be
interrupted.</p>
<p>Raises a <code><a title="wasmtime.WasmtimeError" href="#wasmtime.WasmtimeError">WasmtimeError</a></code> if this store's configuration has not been
configured to enable interruption.</p>
<p>For more information about this be sure to consult the Rust documentation:
<a href="https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Store.html#method.interrupt_handle">https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Store.html#method.interrupt_handle</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interrupt_handle(self) -&gt; &#34;InterruptHandle&#34;:
    &#34;&#34;&#34;
    Creates a new interrupt handle through which execution of wasm can be
    interrupted.

    Raises a `WasmtimeError` if this store&#39;s configuration has not been
    configured to enable interruption.

    For more information about this be sure to consult the Rust documentation:
    https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Store.html#method.interrupt_handle
    &#34;&#34;&#34;

    return InterruptHandle(self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.Table"><code class="flex name class">
<span>class <span class="ident">Table</span></span>
<span>(</span><span>store: wasmtime._store.Store, ty: wasmtime._types.TableType, init: Union[wasmtime._value.Val, int, float, NoneType, ForwardRef('<a title="wasmtime.Func" href="#wasmtime.Func">Func</a>'), Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new table within <code>store</code> with the specified <code>ty</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Table:
    _ptr: &#34;pointer[ffi.wasm_table_t]&#34;

    def __init__(self, store: Store, ty: TableType, init: IntoVal):
        &#34;&#34;&#34;
        Creates a new table within `store` with the specified `ty`.
        &#34;&#34;&#34;

        if not isinstance(store, Store):
            raise TypeError(&#34;expected a `Store`&#34;)
        if not isinstance(ty, TableType):
            raise TypeError(&#34;expected a `TableType`&#34;)

        init_val = Val._convert(ty.element, init)

        ptr = ffi.wasm_table_new(store._ptr, ty._ptr, init_val._unwrap_raw().of.ref)
        if not ptr:
            raise WasmtimeError(&#34;Failed to create table&#34;)
        self._ptr = ptr
        self._owner = None

    @classmethod
    def _from_ptr(cls, ptr: &#34;pointer[ffi.wasm_table_t]&#34;, owner: Optional[Any]) -&gt; &#34;Table&#34;:
        ty: &#34;Table&#34; = cls.__new__(cls)
        if not isinstance(ptr, POINTER(ffi.wasm_table_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        ty._ptr = ptr
        ty._owner = owner
        return ty

    @property
    def type(self) -&gt; TableType:
        &#34;&#34;&#34;
        Gets the type of this table as a `TableType`
        &#34;&#34;&#34;

        ptr = ffi.wasm_table_type(self._ptr)
        return TableType._from_ptr(ptr, None)

    @property
    def size(self) -&gt; int:
        &#34;&#34;&#34;
        Gets the size, in elements, of this table
        &#34;&#34;&#34;
        return ffi.wasm_table_size(self._ptr)

    def grow(self, amt: int, init: IntoVal) -&gt; int:
        &#34;&#34;&#34;
        Grows this table by the specified number of slots, using the specified
        initializer for all new table slots.

        Raises a `WasmtimeError` if the table could not be grown.
        Returns the previous size of the table otherwise.
        &#34;&#34;&#34;
        init_val = Val._convert(self.type.element, init)
        ok = ffi.wasm_table_grow(self._ptr, c_uint32(amt), init_val._unwrap_raw().of.ref)
        if not ok:
            raise WasmtimeError(&#34;failed to grow table&#34;)
        return self.size - amt

    def __getitem__(self, idx: int) -&gt; Optional[Any]:
        &#34;&#34;&#34;
        Gets an individual element within this table.

        Returns `None` for null references in the table (i.e. a null `funcref`
        or a null `externref).

        Returns a `Func` for non-null `funcref` table elements.

        Returns the wrapped extern data for non-null `externref` table elements.

        Raises an `WasmtimeError` if `idx` is out of bounds.
        &#34;&#34;&#34;
        if idx &gt;= self.size:
            raise WasmtimeError(&#34;table index out of bounds&#34;)

        if self.type.element == ValType.externref():
            val = Val.externref(None)
        elif self.type.element == ValType.funcref():
            val = Val.funcref(None)
        else:
            raise WasmtimeError(&#34;unsupported table element type&#34;)

        val._unwrap_raw().of.ref = ffi.wasm_table_get(self._ptr, idx)
        return val.value

    def __setitem__(self, idx: int, val: IntoVal) -&gt; None:
        &#34;&#34;&#34;
        Sets an individual element within this table.

        `idx` must be an integer index.

        The `val` specified must be convertible into this table&#39;s element
        type. I.e. for a `funcref` table, `val` must either be a `Func` or
        `None`, and for an `externref` table, `val` may be any arbitrary
        external data.

        Raises a `WasmtimeError` if `idx` is out of bounds.
        &#34;&#34;&#34;
        if idx &gt;= self.size:
            raise WasmtimeError(&#34;Index out of bounds when setting table element&#34;)

        value = Val._convert(self.type.element, val)
        ok = ffi.wasm_table_set(self._ptr, idx, value._unwrap_raw().of.ref)
        if not ok:
            raise WasmtimeError(&#34;Failed to set table element&#34;)

    def _as_extern(self) -&gt; &#34;pointer[ffi.wasm_extern_t]&#34;:
        return ffi.wasm_table_as_extern(self._ptr)

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_owner&#39;) and self._owner is None:
            ffi.wasm_table_delete(self._ptr)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.Table.size"><code class="name">var <span class="ident">size</span> : int</code></dt>
<dd>
<div class="desc"><p>Gets the size, in elements, of this table</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; int:
    &#34;&#34;&#34;
    Gets the size, in elements, of this table
    &#34;&#34;&#34;
    return ffi.wasm_table_size(self._ptr)</code></pre>
</details>
</dd>
<dt id="wasmtime.Table.type"><code class="name">var <span class="ident">type</span> : wasmtime._types.TableType</code></dt>
<dd>
<div class="desc"><p>Gets the type of this table as a <code><a title="wasmtime.TableType" href="#wasmtime.TableType">TableType</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; TableType:
    &#34;&#34;&#34;
    Gets the type of this table as a `TableType`
    &#34;&#34;&#34;

    ptr = ffi.wasm_table_type(self._ptr)
    return TableType._from_ptr(ptr, None)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wasmtime.Table.grow"><code class="name flex">
<span>def <span class="ident">grow</span></span>(<span>self, amt: int, init: Union[wasmtime._value.Val, int, float, NoneType, ForwardRef('<a title="wasmtime.Func" href="#wasmtime.Func">Func</a>'), Any]) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Grows this table by the specified number of slots, using the specified
initializer for all new table slots.</p>
<p>Raises a <code><a title="wasmtime.WasmtimeError" href="#wasmtime.WasmtimeError">WasmtimeError</a></code> if the table could not be grown.
Returns the previous size of the table otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grow(self, amt: int, init: IntoVal) -&gt; int:
    &#34;&#34;&#34;
    Grows this table by the specified number of slots, using the specified
    initializer for all new table slots.

    Raises a `WasmtimeError` if the table could not be grown.
    Returns the previous size of the table otherwise.
    &#34;&#34;&#34;
    init_val = Val._convert(self.type.element, init)
    ok = ffi.wasm_table_grow(self._ptr, c_uint32(amt), init_val._unwrap_raw().of.ref)
    if not ok:
        raise WasmtimeError(&#34;failed to grow table&#34;)
    return self.size - amt</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.TableType"><code class="flex name class">
<span>class <span class="ident">TableType</span></span>
<span>(</span><span>valtype: wasmtime._types.ValType, limits: wasmtime._types.Limits)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TableType:
    def __init__(self, valtype: ValType, limits: Limits):
        if not isinstance(limits, Limits):
            raise TypeError(&#34;expected Limits&#34;)
        type_ptr = take_owned_valtype(valtype)
        ptr = ffi.wasm_tabletype_new(type_ptr, byref(limits.__ffi__()))
        if not ptr:
            raise WasmtimeError(&#34;failed to allocate TableType&#34;)
        self._ptr = ptr
        self._owner = None

    @classmethod
    def _from_ptr(cls, ptr: &#39;pointer[ffi.wasm_tabletype_t]&#39;, owner: Optional[Any]) -&gt; &#34;TableType&#34;:
        ty: &#34;TableType&#34; = cls.__new__(cls)
        if not isinstance(ptr, POINTER(ffi.wasm_tabletype_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        ty._ptr = ptr
        ty._owner = owner
        return ty

    @property
    def element(self) -&gt; ValType:
        &#34;&#34;&#34;
        Returns the type of this table&#39;s elements
        &#34;&#34;&#34;
        ptr = ffi.wasm_tabletype_element(self._ptr)
        return ValType._from_ptr(ptr, self)

    @property
    def limits(self) -&gt; Limits:
        &#34;&#34;&#34;
        Returns the limits on the size of thi stable
        &#34;&#34;&#34;
        val = ffi.wasm_tabletype_limits(self._ptr)
        return Limits._from_ffi(val)

    def _as_extern(self) -&gt; &#34;pointer[ffi.wasm_externtype_t]&#34;:
        return ffi.wasm_tabletype_as_externtype_const(self._ptr)

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_owner&#39;) and self._owner is None:
            ffi.wasm_tabletype_delete(self._ptr)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.TableType.element"><code class="name">var <span class="ident">element</span> : wasmtime._types.ValType</code></dt>
<dd>
<div class="desc"><p>Returns the type of this table's elements</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def element(self) -&gt; ValType:
    &#34;&#34;&#34;
    Returns the type of this table&#39;s elements
    &#34;&#34;&#34;
    ptr = ffi.wasm_tabletype_element(self._ptr)
    return ValType._from_ptr(ptr, self)</code></pre>
</details>
</dd>
<dt id="wasmtime.TableType.limits"><code class="name">var <span class="ident">limits</span> : wasmtime._types.Limits</code></dt>
<dd>
<div class="desc"><p>Returns the limits on the size of thi stable</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def limits(self) -&gt; Limits:
    &#34;&#34;&#34;
    Returns the limits on the size of thi stable
    &#34;&#34;&#34;
    val = ffi.wasm_tabletype_limits(self._ptr)
    return Limits._from_ffi(val)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.Trap"><code class="flex name class">
<span>class <span class="ident">Trap</span></span>
<span>(</span><span>store: wasmtime._store.Store, message: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p>
<p>Creates a new trap in <code>store</code> with the given <code>message</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Trap(Exception):
    def __init__(self, store: Store, message: str):
        &#34;&#34;&#34;
        Creates a new trap in `store` with the given `message`
        &#34;&#34;&#34;

        if not isinstance(store, Store):
            raise TypeError(&#34;expected a Store&#34;)
        if not isinstance(message, str):
            raise TypeError(&#34;expected a string&#34;)
        message_raw = ffi.str_to_name(message, trailing_nul=True)
        ptr = ffi.wasm_trap_new(store._ptr, byref(message_raw))
        if not ptr:
            raise WasmtimeError(&#34;failed to create trap&#34;)
        self._ptr = ptr

    @classmethod
    def _from_ptr(cls, ptr: &#34;pointer[ffi.wasm_trap_t]&#34;) -&gt; &#34;Trap&#34;:
        if not isinstance(ptr, POINTER(ffi.wasm_trap_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        exit_code = c_int(0)
        if ffi.wasmtime_trap_exit_status(ptr, byref(exit_code)):
            exit_trap: ExitTrap = ExitTrap.__new__(ExitTrap)
            exit_trap._ptr = ptr
            exit_trap.code = exit_code.value
            return exit_trap
        else:
            trap: Trap = cls.__new__(cls)
            trap._ptr = ptr
            return trap

    @property
    def message(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the message for this trap
        &#34;&#34;&#34;

        message = ffi.wasm_byte_vec_t()
        ffi.wasm_trap_message(self._ptr, byref(message))
        # subtract one to chop off the trailing nul byte
        message.size -= 1
        ret = ffi.to_str(message)
        message.size += 1
        ffi.wasm_byte_vec_delete(byref(message))
        return ret

    @property
    def frames(self) -&gt; List[&#34;Frame&#34;]:
        frames = FrameList()
        ffi.wasm_trap_trace(self._ptr, byref(frames.vec))
        ret = []
        for i in range(0, frames.vec.size):
            ret.append(Frame._from_ptr(frames.vec.data[i], frames))
        return ret

    def __str__(self) -&gt; str:
        return self.message

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_ptr&#39;):
            ffi.wasm_trap_delete(self._ptr)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>wasmtime._trap.ExitTrap</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.Trap.frames"><code class="name">var <span class="ident">frames</span> : List[wasmtime._trap.Frame]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frames(self) -&gt; List[&#34;Frame&#34;]:
    frames = FrameList()
    ffi.wasm_trap_trace(self._ptr, byref(frames.vec))
    ret = []
    for i in range(0, frames.vec.size):
        ret.append(Frame._from_ptr(frames.vec.data[i], frames))
    return ret</code></pre>
</details>
</dd>
<dt id="wasmtime.Trap.message"><code class="name">var <span class="ident">message</span> : str</code></dt>
<dd>
<div class="desc"><p>Returns the message for this trap</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def message(self) -&gt; str:
    &#34;&#34;&#34;
    Returns the message for this trap
    &#34;&#34;&#34;

    message = ffi.wasm_byte_vec_t()
    ffi.wasm_trap_message(self._ptr, byref(message))
    # subtract one to chop off the trailing nul byte
    message.size -= 1
    ret = ffi.to_str(message)
    message.size += 1
    ffi.wasm_byte_vec_delete(byref(message))
    return ret</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.Val"><code class="flex name class">
<span>class <span class="ident">Val</span></span>
<span>(</span><span>raw: wasmtime._ffi.wasm_val_t)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Val:
    # We can&#39;t let the extern values we wrap `externref`s around be GC&#39;d, so we
    # pin them in `_id_to_extern`. Additionally, we might make multiple
    # `externref`s to the same extern value, so we count how many references
    # we&#39;ve created in `_id_to_ref_count`, and only remove a value&#39;s entry from
    # `_id_to_extern` once the ref count is zero. Finally, we protect both of
    # these maps with a mutex because `externref`s can be created from any
    # thread.
    _pinned_refs_lock = threading.Lock()
    _id_to_extern: typing.Dict[int, typing.Any] = {}
    _id_to_ref_count: typing.Dict[int, int] = {}

    _raw: typing.Optional[wasm_val_t]

    @classmethod
    def i32(cls, val: int) -&gt; &#34;Val&#34;:
        &#34;&#34;&#34;
        Create a new 32-bit integer value
        &#34;&#34;&#34;
        if not isinstance(val, int):
            raise TypeError(&#34;expected an integer&#34;)
        ffi = wasm_val_t(WASM_I32)
        ffi.of.i32 = val
        return Val(ffi)

    @classmethod
    def i64(cls, val: int) -&gt; &#34;Val&#34;:
        &#34;&#34;&#34;
        Create a new 64-bit integer value
        &#34;&#34;&#34;
        if not isinstance(val, int):
            raise TypeError(&#34;expected an integer&#34;)
        ffi = wasm_val_t(WASM_I64)
        ffi.of.i64 = val
        return Val(ffi)

    @classmethod
    def f32(cls, val: float) -&gt; &#34;Val&#34;:
        &#34;&#34;&#34;
        Create a new 32-bit float value
        &#34;&#34;&#34;
        if not isinstance(val, float):
            raise TypeError(&#34;expected a float&#34;)
        ffi = wasm_val_t(WASM_F32)
        ffi.of.f32 = val
        return Val(ffi)

    @classmethod
    def f64(cls, val: float) -&gt; &#34;Val&#34;:
        &#34;&#34;&#34;
        Create a new 64-bit float value
        &#34;&#34;&#34;
        if not isinstance(val, float):
            raise TypeError(&#34;expected a float&#34;)
        ffi = wasm_val_t(WASM_F64)
        ffi.of.f64 = val
        return Val(ffi)

    @classmethod
    def externref(cls, extern: typing.Optional[typing.Any]) -&gt; &#34;Val&#34;:
        ffi = wasm_val_t(WASM_ANYREF)
        ffi.of.ref = None

        extern_id = id(extern)
        with Val._pinned_refs_lock:
            Val._id_to_ref_count.setdefault(extern_id, 0)
            Val._id_to_ref_count[extern_id] += 1
            Val._id_to_extern[extern_id] = extern
        wasmtime_externref_new_with_finalizer(ctypes.c_void_p(extern_id),
                                              _externref_finalizer,
                                              ctypes.byref(ffi))
        return Val(ffi)

    @classmethod
    def funcref(cls, f: &#34;typing.Optional[wasmtime.Func]&#34;) -&gt; &#34;Val&#34;:
        ffi = wasm_val_t(WASM_FUNCREF)
        ffi.of.ref = None
        if f is None:
            return Val(ffi)

        if not isinstance(f, wasmtime.Func):
            raise TypeError(&#34;Expected a Func or None&#34;)

        wasmtime_func_as_funcref(f._ptr, ctypes.byref(ffi))
        return Val(ffi)

    @classmethod
    def ref_null(cls, ty: ValType) -&gt; &#34;Val&#34;:
        &#34;&#34;&#34;
        Create a null reference value of the given type.

        Raise an exception if `ty` is not a reference type.
        &#34;&#34;&#34;
        if ty == ValType.externref():
            return Val.externref(None)
        if ty == ValType.funcref():
            return Val.funcref(None)
        raise WasmtimeError(&#34;Invalid reference type for `ref_null`: %s&#34; % ty)

    def __init__(self, raw: wasm_val_t):
        if not isinstance(raw, wasm_val_t):
            raise TypeError(&#34;expected a raw value&#34;)
        self._raw = raw

    def __eq__(self, rhs: typing.Any) -&gt; typing.Any:
        if isinstance(rhs, Val):
            return self._unwrap_raw().kind == rhs._unwrap_raw().kind and self.value == rhs.value
        return self.value == rhs

    def __del__(self) -&gt; None:
        if hasattr(self, &#34;_raw&#34;) and self._raw is not None:
            wasm_val_delete(ctypes.byref(self._raw))

    def _clone(self) -&gt; &#34;Val&#34;:
        raw = self._unwrap_raw()
        clone = wasm_val_t(WASM_I32)
        wasm_val_copy(ctypes.byref(clone), byref(raw))
        return Val(clone)

    @classmethod
    def _convert(cls, ty: ValType, val: &#34;IntoVal&#34;) -&gt; &#34;Val&#34;:
        if isinstance(val, Val):
            if ty != val.type:
                raise TypeError(&#34;wrong type of `Val` provided&#34;)
            return val
        elif isinstance(val, int):
            if ty == ValType.i32():
                return Val.i32(val)
            if ty == ValType.i64():
                return Val.i64(val)
        elif isinstance(val, float):
            if ty == ValType.f32():
                return Val.f32(val)
            if ty == ValType.f64():
                return Val.f64(val)
        elif isinstance(val, wasmtime.Func):
            return Val.funcref(val)
        elif val is None:
            if ty == ValType.externref():
                return Val.externref(None)
            if ty == ValType.funcref():
                return Val.funcref(None)
        elif ty == ValType.externref():
            return Val.externref(val)
        raise TypeError(&#34;don&#39;t know how to convert %r to %s&#34; % (val, ty))

    def _into_raw(self) -&gt; wasm_val_t:
        raw = self._unwrap_raw()
        self._raw = None
        return raw

    def _unwrap_raw(self) -&gt; wasm_val_t:
        if isinstance(self._raw, wasm_val_t):
            return self._raw
        else:
            raise WasmtimeError(&#34;use of moved `Val`&#34;)

    @classmethod
    def _value(cls, raw: wasm_val_t) -&gt; typing.Union[int, float, &#34;wasmtime.Func&#34;, typing.Any]:
        if raw.kind == WASM_I32.value:
            return raw.of.i32
        if raw.kind == WASM_I64.value:
            return raw.of.i64
        if raw.kind == WASM_F32.value:
            return raw.of.f32
        if raw.kind == WASM_F64.value:
            return raw.of.f64
        if raw.kind == WASM_ANYREF.value:
            return Val._as_externref(raw)
        if raw.kind == WASM_FUNCREF.value:
            return Val._as_funcref(raw)
        raise WasmtimeError(&#34;Unkown `wasm_valkind_t`: {}&#34;.format(raw.kind))

    @property
    def value(self) -&gt; typing.Union[int, float, &#34;wasmtime.Func&#34;, typing.Any]:
        &#34;&#34;&#34;
        Get the the underlying value as a python value

        Returns `None` if the value can&#39;t be represented in Python, or if the
        value is a null reference type.
        &#34;&#34;&#34;
        return Val._value(self._unwrap_raw())

    def as_i32(self) -&gt; typing.Optional[int]:
        &#34;&#34;&#34;
        Get the 32-bit integer value of this value, or `None` if it&#39;s not an i32
        &#34;&#34;&#34;
        raw = self._unwrap_raw()
        if raw.kind == WASM_I32.value:
            return raw.of.i32
        else:
            return None

    def as_i64(self) -&gt; typing.Optional[int]:
        &#34;&#34;&#34;
        Get the 64-bit integer value of this value, or `None` if it&#39;s not an i64
        &#34;&#34;&#34;
        raw = self._unwrap_raw()
        if raw.kind == WASM_I64.value:
            return raw.of.i64
        else:
            return None

    def as_f32(self) -&gt; typing.Optional[float]:
        &#34;&#34;&#34;
        Get the 32-bit float value of this value, or `None` if it&#39;s not an f32
        &#34;&#34;&#34;
        raw = self._unwrap_raw()
        if raw.kind == WASM_F32.value:
            return raw.of.f32
        else:
            return None

    def as_f64(self) -&gt; typing.Optional[float]:
        &#34;&#34;&#34;
        Get the 64-bit float value of this value, or `None` if it&#39;s not an f64
        &#34;&#34;&#34;
        raw = self._unwrap_raw()
        if raw.kind == WASM_F64.value:
            return raw.of.f64
        else:
            return None

    @classmethod
    def _as_externref(cls, raw: wasm_val_t) -&gt; typing.Optional[typing.Any]:
        if raw.kind != WASM_ANYREF.value:
            return None
        extern_id = ctypes.c_void_p(0)
        wasmtime_externref_data(ctypes.byref(raw), ctypes.byref(extern_id))
        if extern_id.value is None:
            return None
        with Val._pinned_refs_lock:
            return Val._id_to_extern.get(extern_id.value)

    def as_externref(self) -&gt; typing.Optional[typing.Any]:
        &#34;&#34;&#34;
        Get the extern data referenced by this `externref` value, or `None` if
        it&#39;s not an `externref`.
        &#34;&#34;&#34;
        return Val._as_externref(self._unwrap_raw())

    @classmethod
    def _as_funcref(cls, raw: wasm_val_t) -&gt; typing.Optional[&#34;wasmtime.Func&#34;]:
        if raw.kind != WASM_FUNCREF.value:
            return None
        ptr = wasmtime_funcref_as_func(ctypes.byref(raw))
        if ptr:
            return wasmtime.Func._from_ptr(ptr, None)
        else:
            return None

    def as_funcref(self) -&gt; typing.Optional[&#34;wasmtime.Func&#34;]:
        &#34;&#34;&#34;
        Get the function that this `funcref` value is referencing, or `None` if
        this is not a `funcref` value, or is a null reference.
        &#34;&#34;&#34;
        return Val._as_funcref(self._unwrap_raw())

    @property
    def type(self) -&gt; ValType:
        &#34;&#34;&#34;
        Returns the `ValType` corresponding to this `Val`
        &#34;&#34;&#34;
        ptr = dll.wasm_valtype_new(self._unwrap_raw().kind)
        return ValType._from_ptr(ptr, None)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="wasmtime.Val.externref"><code class="name flex">
<span>def <span class="ident">externref</span></span>(<span>extern: Union[Any, NoneType]) ‑> wasmtime._value.Val</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def externref(cls, extern: typing.Optional[typing.Any]) -&gt; &#34;Val&#34;:
    ffi = wasm_val_t(WASM_ANYREF)
    ffi.of.ref = None

    extern_id = id(extern)
    with Val._pinned_refs_lock:
        Val._id_to_ref_count.setdefault(extern_id, 0)
        Val._id_to_ref_count[extern_id] += 1
        Val._id_to_extern[extern_id] = extern
    wasmtime_externref_new_with_finalizer(ctypes.c_void_p(extern_id),
                                          _externref_finalizer,
                                          ctypes.byref(ffi))
    return Val(ffi)</code></pre>
</details>
</dd>
<dt id="wasmtime.Val.f32"><code class="name flex">
<span>def <span class="ident">f32</span></span>(<span>val: float) ‑> wasmtime._value.Val</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new 32-bit float value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def f32(cls, val: float) -&gt; &#34;Val&#34;:
    &#34;&#34;&#34;
    Create a new 32-bit float value
    &#34;&#34;&#34;
    if not isinstance(val, float):
        raise TypeError(&#34;expected a float&#34;)
    ffi = wasm_val_t(WASM_F32)
    ffi.of.f32 = val
    return Val(ffi)</code></pre>
</details>
</dd>
<dt id="wasmtime.Val.f64"><code class="name flex">
<span>def <span class="ident">f64</span></span>(<span>val: float) ‑> wasmtime._value.Val</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new 64-bit float value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def f64(cls, val: float) -&gt; &#34;Val&#34;:
    &#34;&#34;&#34;
    Create a new 64-bit float value
    &#34;&#34;&#34;
    if not isinstance(val, float):
        raise TypeError(&#34;expected a float&#34;)
    ffi = wasm_val_t(WASM_F64)
    ffi.of.f64 = val
    return Val(ffi)</code></pre>
</details>
</dd>
<dt id="wasmtime.Val.funcref"><code class="name flex">
<span>def <span class="ident">funcref</span></span>(<span>f: typing.Optional[<a title="wasmtime.Func" href="#wasmtime.Func">Func</a>]) ‑> wasmtime._value.Val</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def funcref(cls, f: &#34;typing.Optional[wasmtime.Func]&#34;) -&gt; &#34;Val&#34;:
    ffi = wasm_val_t(WASM_FUNCREF)
    ffi.of.ref = None
    if f is None:
        return Val(ffi)

    if not isinstance(f, wasmtime.Func):
        raise TypeError(&#34;Expected a Func or None&#34;)

    wasmtime_func_as_funcref(f._ptr, ctypes.byref(ffi))
    return Val(ffi)</code></pre>
</details>
</dd>
<dt id="wasmtime.Val.i32"><code class="name flex">
<span>def <span class="ident">i32</span></span>(<span>val: int) ‑> wasmtime._value.Val</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new 32-bit integer value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def i32(cls, val: int) -&gt; &#34;Val&#34;:
    &#34;&#34;&#34;
    Create a new 32-bit integer value
    &#34;&#34;&#34;
    if not isinstance(val, int):
        raise TypeError(&#34;expected an integer&#34;)
    ffi = wasm_val_t(WASM_I32)
    ffi.of.i32 = val
    return Val(ffi)</code></pre>
</details>
</dd>
<dt id="wasmtime.Val.i64"><code class="name flex">
<span>def <span class="ident">i64</span></span>(<span>val: int) ‑> wasmtime._value.Val</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new 64-bit integer value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def i64(cls, val: int) -&gt; &#34;Val&#34;:
    &#34;&#34;&#34;
    Create a new 64-bit integer value
    &#34;&#34;&#34;
    if not isinstance(val, int):
        raise TypeError(&#34;expected an integer&#34;)
    ffi = wasm_val_t(WASM_I64)
    ffi.of.i64 = val
    return Val(ffi)</code></pre>
</details>
</dd>
<dt id="wasmtime.Val.ref_null"><code class="name flex">
<span>def <span class="ident">ref_null</span></span>(<span>ty: wasmtime._types.ValType) ‑> wasmtime._value.Val</span>
</code></dt>
<dd>
<div class="desc"><p>Create a null reference value of the given type.</p>
<p>Raise an exception if <code>ty</code> is not a reference type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def ref_null(cls, ty: ValType) -&gt; &#34;Val&#34;:
    &#34;&#34;&#34;
    Create a null reference value of the given type.

    Raise an exception if `ty` is not a reference type.
    &#34;&#34;&#34;
    if ty == ValType.externref():
        return Val.externref(None)
    if ty == ValType.funcref():
        return Val.funcref(None)
    raise WasmtimeError(&#34;Invalid reference type for `ref_null`: %s&#34; % ty)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.Val.type"><code class="name">var <span class="ident">type</span> : wasmtime._types.ValType</code></dt>
<dd>
<div class="desc"><p>Returns the <code><a title="wasmtime.ValType" href="#wasmtime.ValType">ValType</a></code> corresponding to this <code><a title="wasmtime.Val" href="#wasmtime.Val">Val</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; ValType:
    &#34;&#34;&#34;
    Returns the `ValType` corresponding to this `Val`
    &#34;&#34;&#34;
    ptr = dll.wasm_valtype_new(self._unwrap_raw().kind)
    return ValType._from_ptr(ptr, None)</code></pre>
</details>
</dd>
<dt id="wasmtime.Val.value"><code class="name">var <span class="ident">value</span> : Union[int, float, wasmtime._func.Func, Any]</code></dt>
<dd>
<div class="desc"><p>Get the the underlying value as a python value</p>
<p>Returns <code>None</code> if the value can't be represented in Python, or if the
value is a null reference type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(self) -&gt; typing.Union[int, float, &#34;wasmtime.Func&#34;, typing.Any]:
    &#34;&#34;&#34;
    Get the the underlying value as a python value

    Returns `None` if the value can&#39;t be represented in Python, or if the
    value is a null reference type.
    &#34;&#34;&#34;
    return Val._value(self._unwrap_raw())</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wasmtime.Val.as_externref"><code class="name flex">
<span>def <span class="ident">as_externref</span></span>(<span>self) ‑> Union[Any, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the extern data referenced by this <code>externref</code> value, or <code>None</code> if
it's not an <code>externref</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_externref(self) -&gt; typing.Optional[typing.Any]:
    &#34;&#34;&#34;
    Get the extern data referenced by this `externref` value, or `None` if
    it&#39;s not an `externref`.
    &#34;&#34;&#34;
    return Val._as_externref(self._unwrap_raw())</code></pre>
</details>
</dd>
<dt id="wasmtime.Val.as_f32"><code class="name flex">
<span>def <span class="ident">as_f32</span></span>(<span>self) ‑> Union[float, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the 32-bit float value of this value, or <code>None</code> if it's not an f32</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_f32(self) -&gt; typing.Optional[float]:
    &#34;&#34;&#34;
    Get the 32-bit float value of this value, or `None` if it&#39;s not an f32
    &#34;&#34;&#34;
    raw = self._unwrap_raw()
    if raw.kind == WASM_F32.value:
        return raw.of.f32
    else:
        return None</code></pre>
</details>
</dd>
<dt id="wasmtime.Val.as_f64"><code class="name flex">
<span>def <span class="ident">as_f64</span></span>(<span>self) ‑> Union[float, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the 64-bit float value of this value, or <code>None</code> if it's not an f64</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_f64(self) -&gt; typing.Optional[float]:
    &#34;&#34;&#34;
    Get the 64-bit float value of this value, or `None` if it&#39;s not an f64
    &#34;&#34;&#34;
    raw = self._unwrap_raw()
    if raw.kind == WASM_F64.value:
        return raw.of.f64
    else:
        return None</code></pre>
</details>
</dd>
<dt id="wasmtime.Val.as_funcref"><code class="name flex">
<span>def <span class="ident">as_funcref</span></span>(<span>self) ‑> Union[wasmtime._func.Func, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the function that this <code>funcref</code> value is referencing, or <code>None</code> if
this is not a <code>funcref</code> value, or is a null reference.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_funcref(self) -&gt; typing.Optional[&#34;wasmtime.Func&#34;]:
    &#34;&#34;&#34;
    Get the function that this `funcref` value is referencing, or `None` if
    this is not a `funcref` value, or is a null reference.
    &#34;&#34;&#34;
    return Val._as_funcref(self._unwrap_raw())</code></pre>
</details>
</dd>
<dt id="wasmtime.Val.as_i32"><code class="name flex">
<span>def <span class="ident">as_i32</span></span>(<span>self) ‑> Union[int, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the 32-bit integer value of this value, or <code>None</code> if it's not an i32</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_i32(self) -&gt; typing.Optional[int]:
    &#34;&#34;&#34;
    Get the 32-bit integer value of this value, or `None` if it&#39;s not an i32
    &#34;&#34;&#34;
    raw = self._unwrap_raw()
    if raw.kind == WASM_I32.value:
        return raw.of.i32
    else:
        return None</code></pre>
</details>
</dd>
<dt id="wasmtime.Val.as_i64"><code class="name flex">
<span>def <span class="ident">as_i64</span></span>(<span>self) ‑> Union[int, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the 64-bit integer value of this value, or <code>None</code> if it's not an i64</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_i64(self) -&gt; typing.Optional[int]:
    &#34;&#34;&#34;
    Get the 64-bit integer value of this value, or `None` if it&#39;s not an i64
    &#34;&#34;&#34;
    raw = self._unwrap_raw()
    if raw.kind == WASM_I64.value:
        return raw.of.i64
    else:
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.ValType"><code class="flex name class">
<span>class <span class="ident">ValType</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ValType:
    _ptr: &#34;pointer[ffi.wasm_valtype_t]&#34;
    _owner: Optional[Any]

    @classmethod
    def i32(cls) -&gt; &#34;ValType&#34;:
        ptr = ffi.wasm_valtype_new(ffi.WASM_I32)
        return ValType._from_ptr(ptr, None)

    @classmethod
    def i64(cls) -&gt; &#34;ValType&#34;:
        ptr = ffi.wasm_valtype_new(ffi.WASM_I64)
        return ValType._from_ptr(ptr, None)

    @classmethod
    def f32(cls) -&gt; &#34;ValType&#34;:
        ptr = ffi.wasm_valtype_new(ffi.WASM_F32)
        return ValType._from_ptr(ptr, None)

    @classmethod
    def f64(cls) -&gt; &#34;ValType&#34;:
        ptr = ffi.wasm_valtype_new(ffi.WASM_F64)
        return ValType._from_ptr(ptr, None)

    @classmethod
    def externref(cls) -&gt; &#34;ValType&#34;:
        ptr = ffi.wasm_valtype_new(ffi.WASM_ANYREF)
        return ValType._from_ptr(ptr, None)

    @classmethod
    def funcref(cls) -&gt; &#34;ValType&#34;:
        ptr = ffi.wasm_valtype_new(ffi.WASM_FUNCREF)
        return ValType._from_ptr(ptr, None)

    def __init__(self) -&gt; None:
        raise WasmtimeError(&#34;cannot construct directly&#34;)

    @classmethod
    def _from_ptr(cls, ptr: &#34;pointer[ffi.wasm_valtype_t]&#34;, owner: Optional[Any]) -&gt; &#34;ValType&#34;:
        ty: &#34;ValType&#34; = cls.__new__(cls)
        if not isinstance(ptr, POINTER(ffi.wasm_valtype_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        ty._ptr = ptr
        ty._owner = owner
        return ty

    def __eq__(self, other: object) -&gt; bool:
        if not isinstance(other, ValType):
            return False
        assert(self._ptr is not None)
        assert(other._ptr is not None)
        kind1 = ffi.wasm_valtype_kind(self._ptr)
        kind2 = ffi.wasm_valtype_kind(other._ptr)
        return kind1 == kind2

    def __ne__(self, other: object) -&gt; bool:
        return not self.__eq__(other)

    def __repr__(self) -&gt; str:
        return str(self)

    def __str__(self) -&gt; str:
        assert(self._ptr is not None)
        kind = ffi.wasm_valtype_kind(self._ptr)
        if kind == ffi.WASM_I32.value:
            return &#39;i32&#39;
        if kind == ffi.WASM_I64.value:
            return &#39;i64&#39;
        if kind == ffi.WASM_F32.value:
            return &#39;f32&#39;
        if kind == ffi.WASM_F64.value:
            return &#39;f64&#39;
        if kind == ffi.WASM_ANYREF.value:
            return &#39;anyref&#39;
        if kind == ffi.WASM_FUNCREF.value:
            return &#39;funcref&#39;
        return &#39;ValType(%d)&#39; % kind.value

    def __del__(self) -&gt; None:
        if not hasattr(self, &#39;_owner&#39;) or not hasattr(self, &#39;_ptr&#39;):
            return
        # If this is owned by another object we don&#39;t free it since that object
        # is responsible for freeing the backing memory.
        if self._owner is None:
            ffi.wasm_valtype_delete(self._ptr)

    @classmethod
    def _from_list(cls, items: &#34;pointer[ffi.wasm_valtype_vec_t]&#34;, owner: Optional[Any]) -&gt; List[&#34;ValType&#34;]:
        types = []
        for i in range(0, items.contents.size):
            types.append(ValType._from_ptr(items.contents.data[i], owner))
        return types</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="wasmtime.ValType.externref"><code class="name flex">
<span>def <span class="ident">externref</span></span>(<span>) ‑> wasmtime._types.ValType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def externref(cls) -&gt; &#34;ValType&#34;:
    ptr = ffi.wasm_valtype_new(ffi.WASM_ANYREF)
    return ValType._from_ptr(ptr, None)</code></pre>
</details>
</dd>
<dt id="wasmtime.ValType.f32"><code class="name flex">
<span>def <span class="ident">f32</span></span>(<span>) ‑> wasmtime._types.ValType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def f32(cls) -&gt; &#34;ValType&#34;:
    ptr = ffi.wasm_valtype_new(ffi.WASM_F32)
    return ValType._from_ptr(ptr, None)</code></pre>
</details>
</dd>
<dt id="wasmtime.ValType.f64"><code class="name flex">
<span>def <span class="ident">f64</span></span>(<span>) ‑> wasmtime._types.ValType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def f64(cls) -&gt; &#34;ValType&#34;:
    ptr = ffi.wasm_valtype_new(ffi.WASM_F64)
    return ValType._from_ptr(ptr, None)</code></pre>
</details>
</dd>
<dt id="wasmtime.ValType.funcref"><code class="name flex">
<span>def <span class="ident">funcref</span></span>(<span>) ‑> wasmtime._types.ValType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def funcref(cls) -&gt; &#34;ValType&#34;:
    ptr = ffi.wasm_valtype_new(ffi.WASM_FUNCREF)
    return ValType._from_ptr(ptr, None)</code></pre>
</details>
</dd>
<dt id="wasmtime.ValType.i32"><code class="name flex">
<span>def <span class="ident">i32</span></span>(<span>) ‑> wasmtime._types.ValType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def i32(cls) -&gt; &#34;ValType&#34;:
    ptr = ffi.wasm_valtype_new(ffi.WASM_I32)
    return ValType._from_ptr(ptr, None)</code></pre>
</details>
</dd>
<dt id="wasmtime.ValType.i64"><code class="name flex">
<span>def <span class="ident">i64</span></span>(<span>) ‑> wasmtime._types.ValType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def i64(cls) -&gt; &#34;ValType&#34;:
    ptr = ffi.wasm_valtype_new(ffi.WASM_I64)
    return ValType._from_ptr(ptr, None)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.WasiConfig"><code class="flex name class">
<span>class <span class="ident">WasiConfig</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WasiConfig:
    def __init__(self) -&gt; None:
        self._ptr = ffi.wasi_config_new()

    @setter_property
    def argv(self, argv: List[str]) -&gt; None:
        &#34;&#34;&#34;
        Explicitly configure the `argv` for this WASI configuration
        &#34;&#34;&#34;
        ptrs = to_char_array(argv)
        ffi.wasi_config_set_argv(self._ptr, c_int(len(argv)), ptrs)

    def inherit_argv(self) -&gt; None:
        ffi.wasi_config_inherit_argv(self._ptr)

    @setter_property
    def env(self, pairs: Iterable[Iterable]) -&gt; None:
        &#34;&#34;&#34;
        Configure environment variables to be returned for this WASI
        configuration.

        The `pairs` provided must be an iterable list of key/value pairs of
        environment variables.
        &#34;&#34;&#34;
        names = []
        values = []
        for name, value in pairs:
            names.append(name)
            values.append(value)
        name_ptrs = to_char_array(names)
        value_ptrs = to_char_array(values)
        ffi.wasi_config_set_env(self._ptr, c_int(
            len(names)), name_ptrs, value_ptrs)

    def inherit_env(self) -&gt; None:
        &#34;&#34;&#34;
        Configures the environment variables available within WASI to be those
        in this own process&#39;s environment. All environment variables are
        inherited.
        &#34;&#34;&#34;
        ffi.wasi_config_inherit_env(self._ptr)

    @setter_property
    def stdin_file(self, path: str) -&gt; None:
        &#34;&#34;&#34;
        Configures a file to be used as the stdin stream of this WASI
        configuration.

        Reads of the stdin stream will read the path specified.

        The file must already exist on the filesystem. If it cannot be
        opened then `WasmtimeError` is raised.
        &#34;&#34;&#34;
        res = ffi.wasi_config_set_stdin_file(
            self._ptr, c_char_p(path.encode(&#39;utf-8&#39;)))
        if not res:
            raise WasmtimeError(&#34;failed to set stdin file&#34;)

    def inherit_stdin(self) -&gt; None:
        &#34;&#34;&#34;
        Configures this own process&#39;s stdin to be used as the WASI program&#39;s
        stdin.

        Reads of the stdin stream will read this process&#39;s stdin.
        &#34;&#34;&#34;
        ffi.wasi_config_inherit_stdin(self._ptr)

    @setter_property
    def stdout_file(self, path: str) -&gt; None:
        &#34;&#34;&#34;
        Configures a file to be used as the stdout stream of this WASI
        configuration.

        Writes to stdout will be written to the file specified.

        The file specified will be created if it doesn&#39;t exist, or truncated if
        it already exists. It must be available to open for writing. If it
        cannot be opened for writing then `WasmtimeError` is raised.
        &#34;&#34;&#34;
        res = ffi.wasi_config_set_stdout_file(
            self._ptr, c_char_p(path.encode(&#39;utf-8&#39;)))
        if not res:
            raise WasmtimeError(&#34;failed to set stdout file&#34;)

    def inherit_stdout(self) -&gt; None:
        &#34;&#34;&#34;
        Configures this own process&#39;s stdout to be used as the WASI program&#39;s
        stdout.

        Writes to stdout stream will write to this process&#39;s stdout.
        &#34;&#34;&#34;
        ffi.wasi_config_inherit_stdout(self._ptr)

    @setter_property
    def stderr_file(self, path: str) -&gt; None:
        &#34;&#34;&#34;
        Configures a file to be used as the stderr stream of this WASI
        configuration.

        Writes to stderr will be written to the file specified.

        The file specified will be created if it doesn&#39;t exist, or truncated if
        it already exists. It must be available to open for writing. If it
        cannot be opened for writing then `WasmtimeError` is raised.
        &#34;&#34;&#34;
        res = ffi.wasi_config_set_stderr_file(
            self._ptr, c_char_p(path.encode(&#39;utf-8&#39;)))
        if not res:
            raise WasmtimeError(&#34;failed to set stderr file&#34;)

    def inherit_stderr(self) -&gt; None:
        &#34;&#34;&#34;
        Configures this own process&#39;s stderr to be used as the WASI program&#39;s
        stderr.

        Writes to stderr stream will write to this process&#39;s stderr.
        &#34;&#34;&#34;
        ffi.wasi_config_inherit_stderr(self._ptr)

    def preopen_dir(self, path: str, guest_path: str) -&gt; None:
        path_ptr = c_char_p(path.encode(&#39;utf-8&#39;))
        guest_path_ptr = c_char_p(guest_path.encode(&#39;utf-8&#39;))
        ffi.wasi_config_preopen_dir(self._ptr, path_ptr, guest_path_ptr)

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_ptr&#39;):
            ffi.wasi_config_delete(self._ptr)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wasmtime.WasiConfig.argv"><code class="name">var <span class="ident">argv</span></code></dt>
<dd>
<div class="desc"><p>Explicitly configure the <code>argv</code> for this WASI configuration</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.WasiConfig.env"><code class="name">var <span class="ident">env</span></code></dt>
<dd>
<div class="desc"><p>Configure environment variables to be returned for this WASI
configuration.</p>
<p>The <code>pairs</code> provided must be an iterable list of key/value pairs of
environment variables.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.WasiConfig.stderr_file"><code class="name">var <span class="ident">stderr_file</span></code></dt>
<dd>
<div class="desc"><p>Configures a file to be used as the stderr stream of this WASI
configuration.</p>
<p>Writes to stderr will be written to the file specified.</p>
<p>The file specified will be created if it doesn't exist, or truncated if
it already exists. It must be available to open for writing. If it
cannot be opened for writing then <code><a title="wasmtime.WasmtimeError" href="#wasmtime.WasmtimeError">WasmtimeError</a></code> is raised.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.WasiConfig.stdin_file"><code class="name">var <span class="ident">stdin_file</span></code></dt>
<dd>
<div class="desc"><p>Configures a file to be used as the stdin stream of this WASI
configuration.</p>
<p>Reads of the stdin stream will read the path specified.</p>
<p>The file must already exist on the filesystem. If it cannot be
opened then <code><a title="wasmtime.WasmtimeError" href="#wasmtime.WasmtimeError">WasmtimeError</a></code> is raised.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
<dt id="wasmtime.WasiConfig.stdout_file"><code class="name">var <span class="ident">stdout_file</span></code></dt>
<dd>
<div class="desc"><p>Configures a file to be used as the stdout stream of this WASI
configuration.</p>
<p>Writes to stdout will be written to the file specified.</p>
<p>The file specified will be created if it doesn't exist, or truncated if
it already exists. It must be available to open for writing. If it
cannot be opened for writing then <code><a title="wasmtime.WasmtimeError" href="#wasmtime.WasmtimeError">WasmtimeError</a></code> is raised.</p>
<p>Note that this field can only be set, it cannot be read</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wasmtime.WasiConfig.inherit_argv"><code class="name flex">
<span>def <span class="ident">inherit_argv</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inherit_argv(self) -&gt; None:
    ffi.wasi_config_inherit_argv(self._ptr)</code></pre>
</details>
</dd>
<dt id="wasmtime.WasiConfig.inherit_env"><code class="name flex">
<span>def <span class="ident">inherit_env</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Configures the environment variables available within WASI to be those
in this own process's environment. All environment variables are
inherited.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inherit_env(self) -&gt; None:
    &#34;&#34;&#34;
    Configures the environment variables available within WASI to be those
    in this own process&#39;s environment. All environment variables are
    inherited.
    &#34;&#34;&#34;
    ffi.wasi_config_inherit_env(self._ptr)</code></pre>
</details>
</dd>
<dt id="wasmtime.WasiConfig.inherit_stderr"><code class="name flex">
<span>def <span class="ident">inherit_stderr</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Configures this own process's stderr to be used as the WASI program's
stderr.</p>
<p>Writes to stderr stream will write to this process's stderr.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inherit_stderr(self) -&gt; None:
    &#34;&#34;&#34;
    Configures this own process&#39;s stderr to be used as the WASI program&#39;s
    stderr.

    Writes to stderr stream will write to this process&#39;s stderr.
    &#34;&#34;&#34;
    ffi.wasi_config_inherit_stderr(self._ptr)</code></pre>
</details>
</dd>
<dt id="wasmtime.WasiConfig.inherit_stdin"><code class="name flex">
<span>def <span class="ident">inherit_stdin</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Configures this own process's stdin to be used as the WASI program's
stdin.</p>
<p>Reads of the stdin stream will read this process's stdin.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inherit_stdin(self) -&gt; None:
    &#34;&#34;&#34;
    Configures this own process&#39;s stdin to be used as the WASI program&#39;s
    stdin.

    Reads of the stdin stream will read this process&#39;s stdin.
    &#34;&#34;&#34;
    ffi.wasi_config_inherit_stdin(self._ptr)</code></pre>
</details>
</dd>
<dt id="wasmtime.WasiConfig.inherit_stdout"><code class="name flex">
<span>def <span class="ident">inherit_stdout</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Configures this own process's stdout to be used as the WASI program's
stdout.</p>
<p>Writes to stdout stream will write to this process's stdout.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inherit_stdout(self) -&gt; None:
    &#34;&#34;&#34;
    Configures this own process&#39;s stdout to be used as the WASI program&#39;s
    stdout.

    Writes to stdout stream will write to this process&#39;s stdout.
    &#34;&#34;&#34;
    ffi.wasi_config_inherit_stdout(self._ptr)</code></pre>
</details>
</dd>
<dt id="wasmtime.WasiConfig.preopen_dir"><code class="name flex">
<span>def <span class="ident">preopen_dir</span></span>(<span>self, path: str, guest_path: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preopen_dir(self, path: str, guest_path: str) -&gt; None:
    path_ptr = c_char_p(path.encode(&#39;utf-8&#39;))
    guest_path_ptr = c_char_p(guest_path.encode(&#39;utf-8&#39;))
    ffi.wasi_config_preopen_dir(self._ptr, path_ptr, guest_path_ptr)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.WasiInstance"><code class="flex name class">
<span>class <span class="ident">WasiInstance</span></span>
<span>(</span><span>store: wasmtime._store.Store, name: str, config: wasmtime._wasi.WasiConfig)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WasiInstance:
    _ptr: &#34;pointer[ffi.wasi_instance_t]&#34;

    def __init__(self, store: Store, name: str, config: WasiConfig):
        if not isinstance(store, Store):
            raise TypeError(&#34;expected a `Store`&#34;)
        if not isinstance(name, str):
            raise TypeError(&#34;expected a `str`&#34;)
        name_bytes = name.encode(&#39;utf-8&#39;)
        if not isinstance(config, WasiConfig):
            raise TypeError(&#34;expected a `WasiConfig`&#34;)
        ptr = config._ptr
        delattr(config, &#39;_ptr&#39;)

        trap = POINTER(ffi.wasm_trap_t)()
        ptr = ffi.wasi_instance_new(
            store._ptr, c_char_p(name_bytes), ptr, byref(trap))
        if not ptr:
            if trap:
                raise Trap._from_ptr(trap)
            raise WasmtimeError(&#34;failed to create wasi instance&#34;)
        self._ptr = ptr
        self.store = store

    def bind(self, import_: ImportType) -&gt; Optional[AsExtern]:
        if not isinstance(import_, ImportType):
            raise TypeError(&#34;expected an `ImportType`&#34;)
        ptr = ffi.wasi_instance_bind_import(self._ptr, import_._ptr)
        if ptr:
            return wrap_extern(ptr, self)
        else:
            return None

    def __del__(self) -&gt; None:
        if hasattr(self, &#39;_ptr&#39;):
            ffi.wasi_instance_delete(self._ptr)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="wasmtime.WasiInstance.bind"><code class="name flex">
<span>def <span class="ident">bind</span></span>(<span>self, import_: wasmtime._types.ImportType) ‑> Union[ForwardRef('<a title="wasmtime.Func" href="#wasmtime.Func">Func</a>'), ForwardRef('<a title="wasmtime.Table" href="#wasmtime.Table">Table</a>'), ForwardRef('<a title="wasmtime.Memory" href="#wasmtime.Memory">Memory</a>'), ForwardRef('<a title="wasmtime.Global" href="#wasmtime.Global">Global</a>'), NoneType]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bind(self, import_: ImportType) -&gt; Optional[AsExtern]:
    if not isinstance(import_, ImportType):
        raise TypeError(&#34;expected an `ImportType`&#34;)
    ptr = ffi.wasi_instance_bind_import(self._ptr, import_._ptr)
    if ptr:
        return wrap_extern(ptr, self)
    else:
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wasmtime.WasmtimeError"><code class="flex name class">
<span>class <span class="ident">WasmtimeError</span></span>
<span>(</span><span>message: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WasmtimeError(Exception):
    def __init__(self, message: str):
        self.message = message

    @classmethod
    def _from_ptr(cls, ptr: pointer) -&gt; &#39;WasmtimeError&#39;:
        from . import _ffi as ffi
        if not isinstance(ptr, POINTER(ffi.wasmtime_error_t)):
            raise TypeError(&#34;wrong pointer type&#34;)
        message_vec = ffi.wasm_byte_vec_t()
        ffi.wasmtime_error_message(ptr, byref(message_vec))
        message = ffi.to_str(message_vec)
        ffi.wasm_byte_vec_delete(byref(message_vec))
        ffi.wasmtime_error_delete(ptr)
        return WasmtimeError(message)

    def __str__(self) -&gt; str:
        return self.message</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="wasmtime.loader" href="loader.html">wasmtime.loader</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="wasmtime.wat2wasm" href="#wasmtime.wat2wasm">wat2wasm</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="wasmtime.Caller" href="#wasmtime.Caller">Caller</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.Caller.get" href="#wasmtime.Caller.get">get</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Config" href="#wasmtime.Config">Config</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.Config.cache" href="#wasmtime.Config.cache">cache</a></code></li>
<li><code><a title="wasmtime.Config.cranelift_debug_verifier" href="#wasmtime.Config.cranelift_debug_verifier">cranelift_debug_verifier</a></code></li>
<li><code><a title="wasmtime.Config.cranelift_opt_level" href="#wasmtime.Config.cranelift_opt_level">cranelift_opt_level</a></code></li>
<li><code><a title="wasmtime.Config.debug_info" href="#wasmtime.Config.debug_info">debug_info</a></code></li>
<li><code><a title="wasmtime.Config.interruptable" href="#wasmtime.Config.interruptable">interruptable</a></code></li>
<li><code><a title="wasmtime.Config.profiler" href="#wasmtime.Config.profiler">profiler</a></code></li>
<li><code><a title="wasmtime.Config.strategy" href="#wasmtime.Config.strategy">strategy</a></code></li>
<li><code><a title="wasmtime.Config.wasm_bulk_memory" href="#wasmtime.Config.wasm_bulk_memory">wasm_bulk_memory</a></code></li>
<li><code><a title="wasmtime.Config.wasm_multi_value" href="#wasmtime.Config.wasm_multi_value">wasm_multi_value</a></code></li>
<li><code><a title="wasmtime.Config.wasm_reference_types" href="#wasmtime.Config.wasm_reference_types">wasm_reference_types</a></code></li>
<li><code><a title="wasmtime.Config.wasm_simd" href="#wasmtime.Config.wasm_simd">wasm_simd</a></code></li>
<li><code><a title="wasmtime.Config.wasm_threads" href="#wasmtime.Config.wasm_threads">wasm_threads</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Engine" href="#wasmtime.Engine">Engine</a></code></h4>
</li>
<li>
<h4><code><a title="wasmtime.ExitTrap" href="#wasmtime.ExitTrap">ExitTrap</a></code></h4>
</li>
<li>
<h4><code><a title="wasmtime.ExportType" href="#wasmtime.ExportType">ExportType</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.ExportType.name" href="#wasmtime.ExportType.name">name</a></code></li>
<li><code><a title="wasmtime.ExportType.type" href="#wasmtime.ExportType.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Frame" href="#wasmtime.Frame">Frame</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.Frame.func_index" href="#wasmtime.Frame.func_index">func_index</a></code></li>
<li><code><a title="wasmtime.Frame.func_name" href="#wasmtime.Frame.func_name">func_name</a></code></li>
<li><code><a title="wasmtime.Frame.func_offset" href="#wasmtime.Frame.func_offset">func_offset</a></code></li>
<li><code><a title="wasmtime.Frame.module_name" href="#wasmtime.Frame.module_name">module_name</a></code></li>
<li><code><a title="wasmtime.Frame.module_offset" href="#wasmtime.Frame.module_offset">module_offset</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Func" href="#wasmtime.Func">Func</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.Func.param_arity" href="#wasmtime.Func.param_arity">param_arity</a></code></li>
<li><code><a title="wasmtime.Func.result_arity" href="#wasmtime.Func.result_arity">result_arity</a></code></li>
<li><code><a title="wasmtime.Func.type" href="#wasmtime.Func.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.FuncType" href="#wasmtime.FuncType">FuncType</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.FuncType.params" href="#wasmtime.FuncType.params">params</a></code></li>
<li><code><a title="wasmtime.FuncType.results" href="#wasmtime.FuncType.results">results</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Global" href="#wasmtime.Global">Global</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.Global.type" href="#wasmtime.Global.type">type</a></code></li>
<li><code><a title="wasmtime.Global.value" href="#wasmtime.Global.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.GlobalType" href="#wasmtime.GlobalType">GlobalType</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.GlobalType.content" href="#wasmtime.GlobalType.content">content</a></code></li>
<li><code><a title="wasmtime.GlobalType.mutable" href="#wasmtime.GlobalType.mutable">mutable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.ImportType" href="#wasmtime.ImportType">ImportType</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.ImportType.module" href="#wasmtime.ImportType.module">module</a></code></li>
<li><code><a title="wasmtime.ImportType.name" href="#wasmtime.ImportType.name">name</a></code></li>
<li><code><a title="wasmtime.ImportType.type" href="#wasmtime.ImportType.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Instance" href="#wasmtime.Instance">Instance</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.Instance.exports" href="#wasmtime.Instance.exports">exports</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Limits" href="#wasmtime.Limits">Limits</a></code></h4>
</li>
<li>
<h4><code><a title="wasmtime.Linker" href="#wasmtime.Linker">Linker</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.Linker.allow_shadowing" href="#wasmtime.Linker.allow_shadowing">allow_shadowing</a></code></li>
<li><code><a title="wasmtime.Linker.define" href="#wasmtime.Linker.define">define</a></code></li>
<li><code><a title="wasmtime.Linker.define_instance" href="#wasmtime.Linker.define_instance">define_instance</a></code></li>
<li><code><a title="wasmtime.Linker.define_wasi" href="#wasmtime.Linker.define_wasi">define_wasi</a></code></li>
<li><code><a title="wasmtime.Linker.instantiate" href="#wasmtime.Linker.instantiate">instantiate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Memory" href="#wasmtime.Memory">Memory</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.Memory.data_len" href="#wasmtime.Memory.data_len">data_len</a></code></li>
<li><code><a title="wasmtime.Memory.data_ptr" href="#wasmtime.Memory.data_ptr">data_ptr</a></code></li>
<li><code><a title="wasmtime.Memory.grow" href="#wasmtime.Memory.grow">grow</a></code></li>
<li><code><a title="wasmtime.Memory.size" href="#wasmtime.Memory.size">size</a></code></li>
<li><code><a title="wasmtime.Memory.type" href="#wasmtime.Memory.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.MemoryType" href="#wasmtime.MemoryType">MemoryType</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.MemoryType.limits" href="#wasmtime.MemoryType.limits">limits</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Module" href="#wasmtime.Module">Module</a></code></h4>
<ul class="two-column">
<li><code><a title="wasmtime.Module.deserialize" href="#wasmtime.Module.deserialize">deserialize</a></code></li>
<li><code><a title="wasmtime.Module.exports" href="#wasmtime.Module.exports">exports</a></code></li>
<li><code><a title="wasmtime.Module.from_file" href="#wasmtime.Module.from_file">from_file</a></code></li>
<li><code><a title="wasmtime.Module.imports" href="#wasmtime.Module.imports">imports</a></code></li>
<li><code><a title="wasmtime.Module.serialize" href="#wasmtime.Module.serialize">serialize</a></code></li>
<li><code><a title="wasmtime.Module.validate" href="#wasmtime.Module.validate">validate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Store" href="#wasmtime.Store">Store</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.Store.gc" href="#wasmtime.Store.gc">gc</a></code></li>
<li><code><a title="wasmtime.Store.interrupt_handle" href="#wasmtime.Store.interrupt_handle">interrupt_handle</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Table" href="#wasmtime.Table">Table</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.Table.grow" href="#wasmtime.Table.grow">grow</a></code></li>
<li><code><a title="wasmtime.Table.size" href="#wasmtime.Table.size">size</a></code></li>
<li><code><a title="wasmtime.Table.type" href="#wasmtime.Table.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.TableType" href="#wasmtime.TableType">TableType</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.TableType.element" href="#wasmtime.TableType.element">element</a></code></li>
<li><code><a title="wasmtime.TableType.limits" href="#wasmtime.TableType.limits">limits</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Trap" href="#wasmtime.Trap">Trap</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.Trap.frames" href="#wasmtime.Trap.frames">frames</a></code></li>
<li><code><a title="wasmtime.Trap.message" href="#wasmtime.Trap.message">message</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.Val" href="#wasmtime.Val">Val</a></code></h4>
<ul class="two-column">
<li><code><a title="wasmtime.Val.as_externref" href="#wasmtime.Val.as_externref">as_externref</a></code></li>
<li><code><a title="wasmtime.Val.as_f32" href="#wasmtime.Val.as_f32">as_f32</a></code></li>
<li><code><a title="wasmtime.Val.as_f64" href="#wasmtime.Val.as_f64">as_f64</a></code></li>
<li><code><a title="wasmtime.Val.as_funcref" href="#wasmtime.Val.as_funcref">as_funcref</a></code></li>
<li><code><a title="wasmtime.Val.as_i32" href="#wasmtime.Val.as_i32">as_i32</a></code></li>
<li><code><a title="wasmtime.Val.as_i64" href="#wasmtime.Val.as_i64">as_i64</a></code></li>
<li><code><a title="wasmtime.Val.externref" href="#wasmtime.Val.externref">externref</a></code></li>
<li><code><a title="wasmtime.Val.f32" href="#wasmtime.Val.f32">f32</a></code></li>
<li><code><a title="wasmtime.Val.f64" href="#wasmtime.Val.f64">f64</a></code></li>
<li><code><a title="wasmtime.Val.funcref" href="#wasmtime.Val.funcref">funcref</a></code></li>
<li><code><a title="wasmtime.Val.i32" href="#wasmtime.Val.i32">i32</a></code></li>
<li><code><a title="wasmtime.Val.i64" href="#wasmtime.Val.i64">i64</a></code></li>
<li><code><a title="wasmtime.Val.ref_null" href="#wasmtime.Val.ref_null">ref_null</a></code></li>
<li><code><a title="wasmtime.Val.type" href="#wasmtime.Val.type">type</a></code></li>
<li><code><a title="wasmtime.Val.value" href="#wasmtime.Val.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.ValType" href="#wasmtime.ValType">ValType</a></code></h4>
<ul class="two-column">
<li><code><a title="wasmtime.ValType.externref" href="#wasmtime.ValType.externref">externref</a></code></li>
<li><code><a title="wasmtime.ValType.f32" href="#wasmtime.ValType.f32">f32</a></code></li>
<li><code><a title="wasmtime.ValType.f64" href="#wasmtime.ValType.f64">f64</a></code></li>
<li><code><a title="wasmtime.ValType.funcref" href="#wasmtime.ValType.funcref">funcref</a></code></li>
<li><code><a title="wasmtime.ValType.i32" href="#wasmtime.ValType.i32">i32</a></code></li>
<li><code><a title="wasmtime.ValType.i64" href="#wasmtime.ValType.i64">i64</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.WasiConfig" href="#wasmtime.WasiConfig">WasiConfig</a></code></h4>
<ul class="two-column">
<li><code><a title="wasmtime.WasiConfig.argv" href="#wasmtime.WasiConfig.argv">argv</a></code></li>
<li><code><a title="wasmtime.WasiConfig.env" href="#wasmtime.WasiConfig.env">env</a></code></li>
<li><code><a title="wasmtime.WasiConfig.inherit_argv" href="#wasmtime.WasiConfig.inherit_argv">inherit_argv</a></code></li>
<li><code><a title="wasmtime.WasiConfig.inherit_env" href="#wasmtime.WasiConfig.inherit_env">inherit_env</a></code></li>
<li><code><a title="wasmtime.WasiConfig.inherit_stderr" href="#wasmtime.WasiConfig.inherit_stderr">inherit_stderr</a></code></li>
<li><code><a title="wasmtime.WasiConfig.inherit_stdin" href="#wasmtime.WasiConfig.inherit_stdin">inherit_stdin</a></code></li>
<li><code><a title="wasmtime.WasiConfig.inherit_stdout" href="#wasmtime.WasiConfig.inherit_stdout">inherit_stdout</a></code></li>
<li><code><a title="wasmtime.WasiConfig.preopen_dir" href="#wasmtime.WasiConfig.preopen_dir">preopen_dir</a></code></li>
<li><code><a title="wasmtime.WasiConfig.stderr_file" href="#wasmtime.WasiConfig.stderr_file">stderr_file</a></code></li>
<li><code><a title="wasmtime.WasiConfig.stdin_file" href="#wasmtime.WasiConfig.stdin_file">stdin_file</a></code></li>
<li><code><a title="wasmtime.WasiConfig.stdout_file" href="#wasmtime.WasiConfig.stdout_file">stdout_file</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.WasiInstance" href="#wasmtime.WasiInstance">WasiInstance</a></code></h4>
<ul class="">
<li><code><a title="wasmtime.WasiInstance.bind" href="#wasmtime.WasiInstance.bind">bind</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wasmtime.WasmtimeError" href="#wasmtime.WasmtimeError">WasmtimeError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>